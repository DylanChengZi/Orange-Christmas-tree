Hvsmj282oRfuru8dkSSztfPndR1YFvu/wCeaLDLPiC4i1jT/sl35f8AaEiNs8x/m3FuW/i3LWfbXF3b3EWk6T/rY9vnXH3v4uW/nVee4u7jWPN1D7R5Vx/qZLj7zr8/zH+6v+7/AH8VRnt/7H0+7li1aS7+0fcuI/3So393+H/9l6LAb/8AwkEVvfxTRTSSy/LMn2hFWKVju3fd+b+783/2VS29xDceVdyzf2f/ABzfw/Kf4f8Ae/3ay9O8P/6RFqHm+V88e+3uH8qLdt4/2vvdNtaWoaPLcaha6hd/uv30fkx26bmf67v733qLAZlxrEtvb6jD/Z8cWn7GdJJNrM83MkbfL/Fuy3/A625/GMv9n+T5v9nyyPve3j2sqR45Y/8AfL1iX9vd6fcRahF9n+/Jsk+aeVM4HTdtXvXZ6vp8X/CPxRahLbxS/feS4/dM/faP73ZaLAY1vqGn3Fvp/kzXFpFGnkQ3Fxt+6P4vl/3f4az9Y8QxW9xqMsXmQxfL/pF4m2J5MY3D+9t4+6tVb/8AtC4860/49Ivm2Rx7vNTuMJ/Crf8As9ZWoaf9ouJrSWK4u5bhP39xsZei7Nx3bdtFgNTw9o8Wof8AL3Hd+ZMyf6Q7LL5YVvm+X5V61Y1i3u7i4iiiu5NQi++kcd0u5GC8cL/DxXOeFtQ+z280P2T/AEvZsT+L5dv3tv8AFXR6NqEun5+ySx2kvzf6P97f9MfMy8bfvLTAfb+H9Q1D7XLLafa5ZE2TXEiKuzHVgV+9Vzw9b/aLe7ltIo7uX/f82X72C33tvzNu/wC+KnHiCG4tz/xMLPzdm/8A0fcu9i2NoX/d/iqncah/x9yxXccUu9Xf7Ha+Ur46Ln727dQBsXHijULfOnzRR/a433+XH/qoozjb/X/vus62+1/Z7yGaL/WOs32e33KyfL95i/y/eX+78tZU+o6frGnxXd3dyS6rI7PJp+xfkXdhVz95fl2/xVDbahqFxcTWkUVvaRXH7h7i4fayKWYBfn/vMv8A45QBW8Ufa7j7L5v+ieXuR/Mfcz/MNud/zfLXWeH7f+z8+dNJ/r/n+Rpd+cbeP9rtWNp2oS6fPafuv7Pu5J9jyfLL+7+Tc2d3yf7Kr/FWtp2oS3Goat5s1xL91/tlvDtiTDY25/vbV/4DvoA3b/T7S4/c+VHaQ20mzy5E/evIV+9lflf5flrmLj7XcW8UX9n/AGuLZG8Ekn+tRdueX/i/u1N/wkEtxo00V3FJafvpE/0iF5Z3+X/x1m/3Vo1DUNQ/dxf6RFFcbXSP5f3sm35VC/3VVW/ioAuW+nS2/wBsllij+yRpHvjkRdv3f4N/yp8v/of8Nc34g1CK41Ca7ii/df8ATRPN+bb8v3WXev8A8RW1rHjn7PceTLpUl3FGi+fJI6sqScfKw+7/ABUC41C3uJtQ+yW8VpsZE+z7V+XY3zN/srx83y0Ac3cW81vo/my/vbvYuy4kTayLu+ZPlbb8vy/e/KrH/MPOoXdrb+bsWB7iP/Xv22ltzfNu/i2/dqn9n1XT9QPlXcn2SR2f/R9vzsPvf7T7m/i/up/u10moaPLb2+n+bN9r+6j29u6+bE237+5/4uP8/wAIBl3FvaahbzSy6hcWkUf3I9jfvWC5+X5d237vy/73zVn6N5tvcTahdxfZIpPkSSTc0Ttu3lVZfuf/AGFdFrHiiK3+y6fp8X+iXn37iSbzd/bcn+796s7UNQiuPO/0uSXy/kjt5E3M7dkG35V/hz/v0Aalt5txcH7Jp8moRWe7fJeJu34/hB+6/wAy/wB3+7Wjo32TT7aa7h0/7J/fk+Vldv7uPvfLtX/vuoRcfZ7f7XaQxzeZt8+PY+5/lQbQP723+L5V+eqGnahaYiiu9PktPtD/AD/Z5t0r43Yz/c/h+X+HfQBu6d/ZOoC0u7vy5vL8vfcR7trt5H8W7b8qqf4vyqbUPD+n3/2uWKKP/XyTz+ZvZt23C/wsvrSadb2n9nzedp9xafPse3+aWLb5g2t833f4a0rbw9p+oXGn/uvstpHu32cm6JvvN/wL+Jv+BPQBj22n6rb6fNLp/ly/2ftSC4k3Nsbjd+7Xbv2rltqt82F+9WdbXMtxcRS/2t9r1X5t95GifJ8vyrIH279zf/E/NXXT6fF9ni/sn7HL/wBM7jd5SKN21ivzb2+Xbtrnrfw/p/8AwkB/sn7P5t4nn+ZGjMu3ptx/vMzfi1AHQ6fb/aM3f7v92kkE/wBofzflGP73+1u/7761hax/pFvFd6tp9v8AfaBPvbou3X7yfeO7b/f9Kvax4f1v99Daah/pe9YEkt4NsSKd33l+b5tvzbv9vb/Ctcbf6xLc6fNaQyyf6O8kH2y4RW+0N0l4+78rfxUAdqLeLxBp9pFp/wDy7pv8uP5djbf7rf3dy/8AfdRaxp8uoaP5MX775NkEcj7Vdd3LAbvk/wC+a5K21jVrfT/7W863miuJ1SDy02yv/wB8/drU8PW+oaxp93d3U1xaafvjSC3s0Vfl2/7rMy0FIo2+oRaP50U32jULuRPn+0P5myTc3yrEy7UZvm/77qx440/T9Q8H3nk+X5skHnwSW6IsSMOdn952/h3V0Gnafp+j6f8A2TafaPNk3P8AaPIbcn+z/e7n+GuX8YW82n6fFp837r/pn/F95+/3q5q2wz5r8UqYdFLNwd2a8R1u8+26hnPA4r3H4vkaTp8kfTd0r57mfbd7u2M1xUI3uxPQNVmwEjHpmm6LbGWfOM1WmJuJQ3rwK67wzpfzR5HUZrqk+WIr6HSeHrQjau3uK9GtoPselTMRg4rD8OaUrSA46Gug8SSfZtHmA44rzN2I8Q8STebeTfWuUnHDVvarJ5l1L9axZFypr0aS0A9j/YxuPs/xphT5P31hOnz9P4W/9lr7t0bwvFp+oTXd1FHF++bZ5m1lfA+9ht3pX59/sqzXEXx18PxW3D3K3Nuc+jQSA7f9qvu+/wDD8tvp+oebqH2uXfJs8x/NZ/mHTbtX0+X5vmrrQHyL+3/r0Op+JPBkFr/qY4Lub/Z3M0anH/fuvnnwha+feFyMha+mf25fC+pxeH/Bl/cWnlpp8k1sWx2kCurN8q/e2NXz34FgxayPjk0qkuWIFbxQN8+BVbS7Ut2qTVnNxdVr6LYkqOK5+bliSi1p9ngjiu10qLbbisa2s9q5xXQ6ehWCuScrmiJa8f1CE2V9PATny3K5/GvXyME15r8R7T7J4gaUcLOob8e9XQl71iWjKtpiD6EV9P8A7H8VxbSeI7603NMots4bC7f3u5W9iP5V8owT4IBP419MfsoXcksmu6fHCkxkhiuCJFyMRuf/AIqu9LUk+rPB2sS6/q8X2uL7JLZu2+3k3MyY3Y5f5u9e1aOf9Gz/ALIrznwP5t/cajLL/cVE+T+Hrt3fxLXoOnfuNP8AWu+mtDKTsNduXNT2EGcsarN9w1T1zxfoXgm2tp9f1e10qO5kEUJuX2729B+n510WIbOjhGWxU1wcJUMA+apbn/V1JAmnLku1XarWK4iPuasigsa4BUA1n6hEJhs960JDyKpKd97t96mwGY1hNY5P+sjqWzuyk4cHBKgVv4xxWff6CtziW1YQzryV/hf/AArOUX0KuGr6DpnjPQ7vRdatY9Q0y8QpLC4yr/8AxLD+9X5u/Gv4V3XwW8e3WiyBrnSpSZrC5I4liY8K3uv3Wr9GbO4ltZjHICki8MrV5z+1F8IV+LHw6meziD+IdLBubBgOWGPnh/4EB/30q1zzgpxsdEJH5/Q3m9cE1ja64NvLz2psdyUYiqGq3O6CTJ7VwpWdjpvoebTDbqUv+8avQ8A1UvBt1KX/AHqtQng11HMXol5BrprHm3Arl45eBXQ6bODEBXNVNYHN+K1/1v0NN8NSed4dePvE5FS+Kf8Alp9DVDwjJlb2D1CsP1rWOxm92c/ff8fp+tfQfiCDZolnGOqxqPyX/wCtXhEtr5mqRqf4nA/WvobxBBuQjPas6+8SqC3MTwzF5anNej6Wu2FcVwHh1PN247mvSNKjCQgH0rHc6CO6bKnNYSrmVvrW/fAMjYrD2bJDQBPEnFKU55qW3WnzR4U1JZnXQ+Q1jPlWNa9w3UVmTD5qAJrU/NW7YH94lc/bNhwK3rH76moAbYHOl6n/AL/9a9n+GHlXHgj/AJafu5T/ABsvcY/3vm/9BrxPR5zs1WH08wj/AGute1fB63tLjwvH50Ukv+k7P4vl6Y+79a6KbszGpsdFbW8un3E1p5v97958squvHzH/AHWI/u/LXwH8QfDcul+L9U0e8ZbS4t7l4t5HG3kZ+m3nNffdtcfZ7j/S7v8A0uT/AJZ3DrEyN0Lf7S9fmavlP9qjwX/ZniiHXEcy2upZjklx1kjOOf8AeXb/AN8tXcnc4WfNOoGK3nMUJ/dVQYk5q5c25BOarbatDK5HNfb9v4w8M3HwA8KS+IYo9Ql/s9YfLk+9KsfBT/gO3dXxLt9q+nP2dfD8ur6PNqEU1xL/AGXMv2Wzjf5UYr8zkbfnqgN/TvgtqH2jw14ru7u81DT9nnJbx/v5bSMNw0ZDM0iLlf8AaX/ar6K8PafL/aFrqF3d2+oafJ9+PZt6rx97c33eu7bWBqHk/Z9Kli/e6fvaaaSObyoEYjhz/Ey7cr+H8X8OLp1xp+j6hNaS+Z+8+f8A0efzdmeBwzMu7/ZasHoB1WoaxaW+v3cNpD/Z8W/f5dvMzRJkcNt+982P4VaqY1CLUPKi1b99/A9vsESy+m47vr83y/c/75w/3ur3FrFaRR6hLvbZcbDEz+WO/wD6Cap21xaW9xaw/wCqi8/Y9vIiyqjScn/9nctNAemfD7T5YNY8q7ijimjhbZ93d5e4f3foK7+4tyAa83+C1vFceJ9Rli/54N/q/wDV7dwC4+b2NetXNsMGqRojjdSU7WrmLqMljXbX9rkNxWFPY8nIpkHIa/AU0mZlBzt7VgDUJv7P827m/gVLXy03Nb9c5Ma7lrofGmqT6OdOWzk8qaWUq8mzOB0/9mrC1DR4tQuJvskVv5Un3/Mm2ru9v9nd/wCh0ErQhnuLu31iLzbv7X91/wB269/fd9f9rlqrW2sf2fbzRWn7r52n8y3RmZMN3P8ABt/2a1xb/Z7c2kun2935iMiSSPtVF+b5c7vlZf8A2T/arPGjxXFwfK1bzfs6b/sdw7MyY6rjduZW/vfw0GhattY1C4uPK/0f94nnPHcOyx3Hy/eB2/e4p+oeVcah5uoTW93LIiulvv2yp32n+HdUdv4ou/7P1G0l0+T7JG8cCXFv80W7bwx/u/8AxVW7bUP7Q/0SK0j/ANi4kfar+udy/eoAgGoS6fbzS+Vby/8APl87bk+b7v8AF83+f9mm+HriXxBqE39oSyebv3wfaH+Z1PXr8v8A3z/47U9/9rt/Ku5Zo/7KkfYklxtjlST+HI2/db/gVOuNHh0f/S/KvJYrhP3NxZz7Ynb+7hf++qAM/TtQh+0Rf6X9rtN//HvI/ntx/uru/wC+l+Wrlt4gl/tCaL+z7e7tJL1v+PhG+8eTgr83/fS1heMPN1jULXyrSSKWR/I+2eQzLEo/8e+ata2/tC4t5rSW0j+126K/+kJ8svy+jUAN8Uf2t+61DT9P/s/52/ebFXYu7/d+b/vpv91an077Xb+VqH2uzliuPuXEe7t/Dnbu700W+oW+nxS/u7SKRGeG3j+7Lj+EHdu/8e/Cqfg630+31C782X+NfJt40ZlSPbk43N/nZQUdRqGn6hrGnmWXULPyt6wvHbu0TP8AL93O1v8Ad+as+fWLvT/+JfLaXEv2N98Mdw7bnUjPB3bX24/hVf8AgNbE9v8A2x/qpfN0+RFmmt5NrbMdGBVf/ifrWPf+IJdH87SYotUu/Mf/AI9967eMYVDu3L8tAEmjahpOsW8Ut3aR+d/qU+xvubc/s33W/houPO/dfvpLuKN5N/ybtnzcZ+bb6VPcW+oXFwf7PtLeK02N5P2jesu7b2/vfd+61RaN/a1vo/8Apen+b9s/cXUlx/rdu71+7/49toAzdY0//VSxS2/2v/ppt2/mv+1/wGux8O3UEFtCtve3v207diGRlTb8/wB3Y38PP3q4bWNQtNPuJvK1CT7++CPerReZ/d3/AN7/AGfvVr/8JTLcW8Vp5tnLqv8Ayxk3r5r/AC/dHy7f/ZvkoA6e28640+7+16hJ5u/z3vNjfvV7N8q7f/Zq/OT4wafcaV8SfElpcy/aJmvZJfO/56Kx3K35MPyr78uPHP2e3/ey+dLJ++/eIvyNx03fLXxj+1bFCvxdupLWGOFZ7eNv3f8ACwBX/wBloA8fHSiiirJH0qO0Th0Yq6nIIpueDUdQ0I9/+FfxC/tGBYpnxdRcOCfve9e46DrcUrq2cN6ivifwpPdw67ZGyLfaGmVFVVyXz2r660+3/s+cxf8ALWOvOq01uj0sNWb9xnsminzEUhutdXZxnb96vNvDOrtIi5Nd/pt4GUc1yw0PROg0+UwNXQ2t2XXg1zMUg4xWja3YQc9K2LOstrj5a+ZP2kfHEXhf4j6VLD+9/wBC/wBN+RWbbu4/4FXrPj34jWPw/wDDtzql3L8qrtijzy79gK+EPE/jG78aa9eareSF57hyzZP3R2X8BXZh6bnK/Q8rF1YxXKfRenaxL4v0eKW0m+1wyf6mTfu2KPX+Krlv5WnzzWs373y0+f5/mXFeA/C34gxeAdfltbqb/iVXn/jkn/fVe5T3EU/lyj/lulXUg4s8hTudfp2n6hrFxFLD9o8qRNjxxptidt33jt/Cr4823uJopbT7XdyPGn2jfuaJvm7Dau3/AMdqvcahq2j2/myy/wB1IY9gaVPl5bH3U/75qpbf2h++tNWlj8q8+T7RcPubb13cq3zf7tSaDRcTXHlTTfaJYtm/7+7/AGDknb/47u+tJbf8fE0U32f938iW/wAqsjfM6t/tU+20/UNQ86G0lt4ovlSe4kdotij7qAf3m+9/3zUFto9p4f1ibzZriKXZseS4vfNVGI+797cvy9KANPV/N0/T5oZZftd3Jtd7e3T5kUsOrL91f9msvWPEEusW+n+VdxxafJt/eR7tsWP+BbpG3D7v8Wym232vWLiaWLUJIov9Slv53zOvuf7v/fVbA0/7Pp832v8A0vUNn7iON/3SfLgZ2tu+Zf8APzVYGfp3h/8A4S+4/tDVov8AiX+TsS4uHVV/gNYg8P6Jb25l0+KO0u97J5kn+qdd33/7xb/ab7v3d3auo+zxf6rzrz+0LdP9Z537qJcc4+VdrVi/2fFo9x+98z7JI/z/AGh1aV/m4zuX/d/776Ur2AkttHu7e3827/1Xy7JN7fOu37oj7L/u7q1tO1DW/wB1qFpF9rij+Sa4k3bU+bG5A34/3d3/AAKr2naxp+of6JL9nhi/jkkd4oovl+8Pm/unjarfWqw1C7t9P8qKb/RI3b7Lb28KytL6Z/i7j7zVSdwIR4g+z+d9rluPK2fJJeOsW9u+T93vu+XdWELe0uNP/tC0/df3JJH3b/Rh/Ft6tuqXWP8AioLfzfEEX95H8z5YkYD7oHzfdb5qvjUItQ0eKXzvtf2dNkPl2rfPIX+7nb821V+9/D/Dt3UwKQ8P/wCj3csuoSfcV0jt0mVtu7ls7vv/AMX86m/tCXmLT7vydPj2+dJGifP3GZP4vlIy272/hrU0bT9K+z3fm6fcXcsjq/7t9qovdvl3fxfw/wC7/dp2oW+n3Fxp80v2f7iww2e9V2L/ABZTc3p95v8AZoALfR5fFH9oRRRf2hLHu/5b/Kn8HH95VpNY0/VtPuIovOjtP3K+dcb23bQ2DjCt6n7ven6db/Z9Qu/skv8ABvSP7U0TSrhBs/h+X/vmobbT/wC37c/uvsnlzbJpJJmaLaP4T8y/gv8A6FXPcaLmoW9pcXGn/urjyo3aHy/uxuu35Vz/AHmzuqhf6hp9vbxfZJY4f78exmZPuYXP3t3+1VnTv+JfrE2ny3dxaWkbtMke9mWL5k/u/wD7XrT/ABB9kuNQi8qWT+HZcXE6yb19vlX/APZq0y0ZNvqH9n+dL5XleZ5bzR/8sJf+A7fp/wCPVpfaP+En1CLzf3Xlw/PJGjbX/wBkbvu7sCrOn29pb6Pd3cUX+l/cnvLh1aKZePuLu/8AHv4vmrIuLe7t9PtbuX91FsjmS3t59sr5ZOpX+H/Z/CtUM0L/AFCW4t5rS0+0fa/l3x/KrPhfuh/7rf8Aju+oLe3m0+4ml1CKT7677Pey7JB/D/eb/wCwrN0a3m1C4PmxW/2q3RpofLRZdmf7xHzfMq/dbd/D8vzVe0bR7u3uPNl8zzY0Z7r7Y+1Yo+csfM/2mNAHRXFx/wAU/NqHh+0uLSKz+d/tD7d8nzfN8zfebP8AtVWuNR/0fSoYtQ+yeZ/rri43btw+7j+78y/521lax4gi8YW9rLF9ntPs7xvDb728pF/hXEfy7tv+1VG40e7uNQml1DT/ALJp+zf9o+ZWRgudoCt83f739xaANu21D+2NYitPNju7verv5n3XUbsZ+78vH8NdVbXGn29vqM32uO7u/wDn38naqNx0+X2+8y/dSuF0/WJvs58ry7T7P/zzh/e88DBX8V+atSe4i0e4mu7vUP7Q8xIfI0+ODdBF252/xcj/AL4oAg1jT/7Y1CaX/TPN2fPbyO0USLu+Rd/8X/Avu1taN5viD97qFp9rtNjQ+ZJ83zdOf73/AOzWFp3iC7uNQ1C7l0+TUIo38mGO43LFF2L4bbu6/wD7Rqa3+16h50V3FeWnmQs6W9m7LFu3eu3/AGl/vf8AoNAGfo1vFo9xd6fqEVv5UkMiTXFx8zP22j860bf7Jp/nWlp9o+438Hm7/wDZx/s5+7WVcaf/AGfb+VL/AGf5u/8A1kjtKqKWzz/e6f8Aj9Q3Fv8AZ7j/AETzIovJ+f5/mf5sfJ/wGgBmoahpOsTxRS2n73Y00McjtAv3t5ZU/wDZf92uhttP8Q+ILi1ltNKj0qGSb5/kbc69sn+Go9Ot9P8AD/8Apf8AZ8kv2j5Hk3r8ihk+U7W/haut07xj9nz5XmebcfJ9n2fck7t83zfL/dX+/QBxusfD/wDti3+13c0lpd7N7+Z829h8hbP8f/j33FrW07wfF/Z+n2mnSyeV5+95JE2s+Odg3fiu7/4mj/kMahFFqt3cWnyM8En3WSQ8bfu/73y10WnXEun6f5UU1xLqsiKjyf8ALJPlZ9x/ubv9mgDIFzqFxp8Xm6TH5Vum9PtE/wArsMjadq/T7v8Acqtp1xLb6hNLaRW/3I/9IuHZmuIwp2+V/f8Amb5q6CeeW41i1hli86KRGSeOP7qN0GMfL/Ed26oftFodGm8qKP77QJ5kDS78Nn+793cv/wC1QA228r+x4pdQu/8AS9+9/wDrptw33v8Aadv/ANdYdx9l/tCbydJk823gXyLiNP3G079qhX/hrc1i3/4SDT/N1CKOKH7nlxwO0v4f3f8AerBHiD7PqFpFFqPm6fJ/yzkm3Sp97odzbvun+79+gBltp/8AaFvN5UX+iW+6Z45PmluGKsd33fqu2q1/4pl+zxafNaW8XmWq/wCkR/61Pm/h+b7u75amn8QfZ9QihtPL8r5n+zyJuXn7udnzbv8AP8Vc/wCILiLUNQmlhikmi3+RB/Ds/u8Jt+VWoAX97rH9n2n2u48mNG/1abZdo/i8z7zfL/Cv3dldoLf7Rp/+q/c/695Nm5k/g2t/tf7O5q4bRtY/4mF3/Z+nyf8APBLi8fdsX+NhG+7ZH/tfxeldZ4e1C71i3iilij/s+P7km9Yokj/2kX/a+7/uUAcxrH/En0/ztPi82G4g3vHGnms/+0dy/wB7/wAdqtb3Goahb6fLNNcff2eZGjNF/H90ou3d/wB8rXfaxbxf2P5UunyS/I1qklw/lN5Yb/abc/8Ae21njUYre3i+yRXH7v5EjjnZWmk2j5gNvyKq/wDs1AFjTreX+0JoZf8Aj7jSNLXy3WCVFK/ebd99vm+b/wBlrWtvA8X9oTeVNJNF8yTeX93+Ilgx+XduYfd/2qqadp8txb/2hNFH9r8+N3+0fNvwoDf7Xy/7Kr/49WlqGoXf9nmKaKP/AEdFf/R0dl2lgV/4F/F/s0APttQtNP0+0ilmk/0N1SD733h93/x3b8zVp6drH9sf2jaWksfmyJ+78t/v/Nhd3zfJu+Zf+AVxuoah9onOnzfZ4opLJrry7jdumXany/7bbv4V/h+8K6m4t/s+nzXdpNb2n+hKn+j/ACqihtn+78v+fvUAZ/iC4l0/yorTUI7uXYqfY490W/A55Rfu/d+9Vn7PFcW813L9otYY3k/eW8G3fjjcvzf5/wCBVRGof2Pcf2hF9n+yff8A9M/ey3Cyc7o/T/d2/Lsp1tqGreINP0m0+yeVFJ9/5G81O/P8Pzbv+A1CAz7jT9Q8Qed9kl/dRoyPcef5SvGcfLn+P7v3fzrlNOt/+Pu0/eahFG8k6fZ4FZdx/iO3+H5V+b7teoW2sTXH/Evi0/zotnkT+YjMqSfMGwH/AIev+9WdqH/Ev1Ca0iiki8x43SOP7zqF+VSv93/ZqwONuLeXxhrEXmzXFpaRusH96JPk9du1/wC9XoFvcf2P53+rmtLeDyf3b+bvwueSq/J/F/47XM6hrGlf8JBFaXf2ia7vEWd7eRPK35+7j+53+WrFxrFpb3E3nfaLvT/vvZyQfNM27I4b/gP3floKRr6x/wAfH9oaV/pc3yxpHv8A3SL/ALJ/E1wOof6R53m/vfvfx+b831rtP7Qu9Q0+aL+0P7Ki3708z5VS3252qF/iXb975v8A2WvGtQ+IseiGSJow3zE152Iu4tDPHf2ktRCanDZIeQgJrwe6YggdyK9I+MOptrXiRbknIaEV5reHcwYfwjFXh17tiJEmmQG4uVA5ANep+GNNLpEQvauK8EaeLmcEjO417l4Y0ERwx/L2rGvK7shRNbQtKWKPcR2rlfiFqPkI8SnrXfXLCwsiemBXi/jnU/tVy5BrlirsZ5/dNulkPvWe/erkp5eqjjrXprQDsfgNcPZ/GzwXJEu921OGPb67m2/+zV+hA/s/R7jUJZftH2vZsSSSR167sqAvyjp9771fm78PLu4sfiJ4WntGVblNTtzGW6A+YvWv0Y1jR5tQuIruWK3iljf995l60m+TovMfyp94rt29/wDarVAfP37aOsRf8KvMNp/qrjU4U/eJtk3BJDwf4l6fNXzd4cg+xeHFm7mvfP29NaP9jeB9FwRsaaZj/C20IoI/76NeH3Mf2PQYYB1wKirsBzUMXn3Y7812ulWQRBxXN6Pb77scV3dtbBEFcVSXQlE0UA8ur9su2Kmwxfu/erCR7YjXNc0RVbqa434s2PmaRZ3o6xybSfqP/rV2TjDGs7xfY/2j4T1OLGWRBIv4f/WrSm/fQHi0DZUV9V/sW6TDf6trdxLJ5UtvHCIz/Czbnba3/fv/AMdr5Sth8q/Svq39iW4u/P12KKKT/WQu9xv27V/eD/gXX7v+zXrxRFj7V+F3nXGnTSy/66R/n+TaqN3x/wDFfLXXalqdr4e0yW6vGkSzh5byomkYfRRyaxvh6G/4R95XVVeSRz8owSN2OR+FafirS11jRfs6iQurrLiN9rPtbO3/AIF92vQjscx83+KfjhrWsePbUQyTafolncrv0+Mj/SMNlWkO3d83y/L93/er0yfTfDfxHsL/AEm7DQa7qiTajaXmN7RFS0ahW/2VhX5f4l3VwPij4TTW+sHUIov+PjUNkP8AeRQv3q1ri3/4R/xf4U1D/l13q6Sf7Pn5P/jsi0K/U+VVevh/aTrq6bX3SPQ/2fviBL4v0ebRLu0+y6ho6Qw/78e3H/fS4+b/AIDXp103GK+UPF+kat4H+IH9o6TqNxp83226R/LfavLAxiQfdZdvl/e/v19P6HrSeJ/DmmaxFGYUvrZLhYz1UMM4qk7npYGu6ilCW6NS2GIRUydajhGIx9KkXvVHsCTHkVUtRvuZD6GrMxwKr2K/61qAL7/dzUaXIJxVaW5IG2okyOaCC/PEtxHhvzqDz/7OzLLLiIfx0scpxXN/FC++x+DLubvGGb/vlW/wrKSNYM/MXx/qNhqnxD8UXumDbp1zqVxNbj0RpGI/nXKXwD7hUCXHPFE77h1rz5LU7FscXqK4vW+tSRdKTVRi7aiE1S2ILCv0rTsrgonBxWQp5rRth8tZSVyouxS8QuXiJ9qz9BzFKzL1KkfrVzXjiHHtVz4eeH7jxNqi6ZZjfdzq3lJ/eIVmx+laRWhnLco6ZD5nirSwP+flD+te86wu+N/9zH868X8OxB/GGlD/AKbp/Ovbbtd6SD6isa/Q1odTG0BRFcKvvXotmMxZ9q4DR4dt4M13lg+6LFYo3G3a4hcisW3bzJiD2rcuDhWFYDoYpWI9aANK3XJNSXA2oabpw3DJpb9tqkDtUlmDePgmqYO7NT3TbieaqqdpNACplZQe1dFpx3jNc9/Dmt/QTvjoAraN1vz/ALw/WvaPg5qE1voCQ/ZEli+0NvuN4XZ93/ZavEPC/wDx4Se+K9m+E2oWltokol3/AGp7ghMfxL8vy/rWsDGZ2Wr/AOkeV5tp/pcafJH97epbO7j/AIEvzVwfxW8Cx+PPDN7oBmEdxt8+wkP/ACzlQNkn+LG5tu7/AGq9QuNYi0/919k+1w+Szp9n3M23dhl21z1xqP2f97F5fk7P9ZInmysvHb71dcVocrR+bniPS7jS7+W2u4ZLa6hcxSwyLgow6isTFfU/7SPga01j/iptPlj+1yP5E3ybfN9G+dvvfw18wXVq0MjAjBBwR6VoibFPivq79jWeVrTX4oZvKl8yMp+CH+H8q+VfIz3r69+Aelw/D3w9aw6hFHaatJML15JEb5PlI2Hb/Eu1W/4HWgWPTPtGrf6XaahFHd2mySH/AEfe29v+ubruVW77d3/Aqm0/R9P1DT/Nh+z2ktmnkfu7pWldjwFP5/xL8uGqPUvFN9rlpNaXTRWURkadJbZzudejeYW3fL/F/wDE1iaxqF3/AGhp8uofZ4rSR5JvMuP3Sp2GTtVtv/AqxsItfvf7Q/s6XT5P9HmZ3kjmRmWP6/8ALTqdvtUuof6PqB/0u38377ySO7NN97a+G2r8q4+ZW3fJXOi30/8Ati7l0+X7J5e1JpI/midf9n5t23r8y15p+0Hrd14WHhhobsPpU6XCzRxblZ2JXc27PIZW+9uahID7H+AeizWt14gmMsd1p4WNIJY33K+ctu+8y9/vfxV6bcwHkV5r+yfd2mr/AAyfUrTT5NKhuLmQpZyTtL5Srtj2jd/u7tv+3XrO3nmtVE0RzU+nnJ4rHvrHbniu5uYFweKwNSiAzxUiPEfHbzR6pAIv+fdn/duyTxfN96M/xt/stXDW2oahcedD5XlTbGRLyRG+T2JWup+LGo6frHlf2VqOn3fybP3c4lbdu5T5fuN/vMtcd9ou/s82n+bHF5m6HzI0VpXU4w0hVvmbd/EtAF+4uJbfUNPtIbvzZY0+fzE3Tvx935vmT/erUuP+Jxo/2u7tPKi+5DHHM27b0P8Atbt392obj7Jb6ha+bLJL+58n7RG7SqkmPvZ+6yt8uflplxp8uj6fNLL/AMTCKObznkt4VbZ2GJN3/jtAANP/AOEfz+9/4/E/5d3ZmT5srz/Fu/utVb+z4ri4iu9PijlljfYn+lNErsfZV/vf3vu1q/aJvs/9oSxeV5iKnl7P3T4+6x+b5Wb5vu1QH2TWLiaKX/iXy7JEfzHZldf72d1AHRi31DUNPu9Pu5fsl3GivN9o2/JJ/d+Xdu6D/apvg7xhp+n3E2kyy29pL8uyORF2v8vY7awrbUP+EfzFLNcRRbNkMm9drr/dwy/NVjTtPi8QXEWnxafp802z9zeXD+VKjD0+XcH/AN5vegDX8Qafd6x/pdpdx/ZLd/nj87bvY/xr/wDtVj6d5uoXHk/a/td3cfO9x8y7Gjb7xKs25eNv+9Tri4it9Pm82WOKXe2+48n/AFWV+98zfxf5FZOjah/Z/nWksUeqxRw/JcWablRf7w+X8/vfSgDTtvFP2i3/ALPl/eyxu2zzERtnzfdD/wB1v7taVg7tq0P20R2E38E6K7xI397Ktt3dPl+7/wCg1g+Hri0t/Kliit/KuJl3/aH2yvjjja3zVq6xqH2f7XFFaXEvmTM/lxzbZfLK8Lh2oJR0NtpqaBqj3Mssd3aSx7EMRMMHzfwn5W2L/wDY1hX/AIftdY8rVrSa8li+ZJre3fzZYu3Td91sVDbXEun29rLLaW93aSP/AKvzm3Ov1+8v/Aq6K38QWmn/AOiQ/wDEqik8vfHcJtZFHTBjVdzf73/j1BaKv2fVre4/0S7ktLS327I7x9u/5mHAZvvf5+Wswahd3Gsf8s9Pl/jt43eW2lb3HzLUOr6haXFxFLd6h/v/AGedomdu2U/9mq2PEEuoed5UVv8AZPJbZHcbVli/2v8ApotAyHUPK+zzWl3Lb3fzrNN9jRZV29P4vmrntP8AD8un3EUuk6hb+b806afcO0sXrtyy7o/97cy+1ac/9oah5XlWlv8AvId80ciLFFK3/TPdu2bv7rfLSW2nxf2fFDdzSfa967PM3KyMP/Htv+zQRYo6d4gtPEGsGHT4v7P1CT/j6s7j5WRt38P8LL/tLXyh8ftTu7/4ma3FdsSbGQWsYPZVH+JNe3/GDT4tQ1DSoZYvNl8mR08ubyv30jxRq/y/d2s+7/gFfOXxLh1CHxbqUeq7zqMZSOV5ZTJvKooB3dxgDmgzZyg6UUDp2/CirKG5opdtG2gs9T/Zy0gXvxBhvZF3Q2MbTsSNwU/dGfm9TX1Hr+n/AG/zvskVv9rt/wDn3/eLt96+VfhZpvjqxAvfDUcq2t44t55AgaJ+c7Wr6xtrf+0LeKWKaP77I9v80XTKFTXPNDUuVmD4J8UW+pxrNbTLJEx/hOcf5wa9S0fU8gfNXwt/wkGrfCDxxqGn/vPsnns/2eT7rx/wsP8AgNe2eD/2htDlhQXE/wBkc/wy9K4PYvVo9GFdfaPqO1vyV61k+JviTpfg7T5LzVLsW9unUnkn6CvnnxX+09pOnWzR6YHv7vsVGEX8a+d/Gfj/AFnx1qL3WqXTOufkhU4RB7Ct6VFvcVTEq1on0r8eP2mdP8f3Gn+H4dF/4omPc8FxJ/x83EhHM+7+Fv8ApnXh3iCzl8PWqXcUoudLnfMN4Okn+y3o3+zXH6Rr5s42trlBc2L/AHon7e49DWpf+L4rDw/NoenSyXdreOrz3Fwiq3HRQv8A7NXoQVjyZylLcx2v5Zrgy19HfAbxRF4n0+bRLv8A4+ovnh6/6s/e/wDHq+aV4HFdB4N8T3XhbXLTUbVystu+7A/iX+JT7EVpJKUbGa0PtfUNPluLj+0JftH7vb/o+9WX/wCyq9p2oS6hcXf2vy4rSz+f7m3/AIE21fyVauW+oaVp/lf88pH2JJIm2d13J0O1fvf7NaFx5Vx/x6SyebH/AMu+/b/F/u//ALNcBsYGnahF9n82WKTypN3k+W6xLK3X+L6c10Y0f+2LebyvLil3s6W8b/Lx7bf/AB2qwuPtGoRRXcUf7t9iafqE7SwJhcbv8/xU4ahaafmKGXypZN2+4t4PKV/qf7tAEenafLb+dFDN+9+/P/seufl3I38O2oNOt9Q0+4P+i3kvl/Iklu/kSvheEx83v/wH/wAei/tiLTx9ktIry78vdN/o7tEu3v8Ad+71+9/sda6AXGn6fbm7tNPuLSX7nl3E7eU//ju5vm6/7lWAzRtR+0W93aahNcaVLJO37uN/ll+bvt6/3dvy/wDoNZdxo81vcRRXeoeV5nzwx/xeX/eI/wBr+7/6D92ltvFH2+4iiu/scX2h2/0eSFmlfA7Yb7u35dzVf/ti00/ypZbS4/dp/Nm+bd/wH+GkBY07T/8AVS6hF9ri3yf8e+xm3I2zqzf+g7vuVz9xp8tx4gi/4+IrT7iSXCeazt9842r83/AVrorjUNPt9HtLvUPM83zlR7e3h+Z5iuB/F821T/e21JqGof8ACQXEXlTSRSx/IlnbvtVF67jv/u/e+9/6DVIDIttHit7fUbu78y78xP8Al4dl/i44+b5urbfm/wCBUmjafaW9v9kii8qWN1/eXCJEzt/eI+8q/wDfPy9a19Ot4v30vlfa/wB9I6See0TOu7hiVX5fZV/GrGnafqFx513aRRxWn/PvI6ytzz95vv8A97dTAr21x9n867tJfskX8fzrt2n5PkCr81ZOsaPFp/lXf2u38qP/AJd/O+Z/9n5aj1DWNQuNY0+Wa7/tCL94k1vG/mqmeOX2rtXpV+28P3f2ebyov4Gd/L+8ke0Dd8ysqd/4v/sQCpp2ny29x9r/AHcunxo3k2/8KKevmf3mp+jahFcW93D/AK7y51RI7dGaK3Xdjd9z73Vi3yirY0fRNP8A7P8AO1X97s/5B8e/zdoXB/3F55/Kn29x9pt5pYore18z53t43ZYn/wCeez+H71ZNDRY/seK3uIvK+z3csjs80mxW2fL67V2/d3f3t1Z+oafFcXH2SL7PLFHtd/M/dKihed3zfNVjw94f+0edaRTRxSx7dkkm6XY277wXb8zblH+zVq40/T7e4P2Ty7uWR2Ty9jefuDfe+X733T/s/J/s0loWhdG8L6VqH72Xy/Nt92+4jfyF9vLDfe+XC7qq3GoWnh/ULXzfMl+dXS4k/dRPGGALOdvPy7sL8v8A49Txb6tp9vNaarF9k8x/IT7Q7fJGFHzY3fw/+hVQuLjUNX8rUIoo/wCz7eGZPM8j907Bsf3t27buw3+xWqGXtYuIri4il0+0t4pZE2Q/Z3VmdTz1Vvl+X/0OmDT9Qt9Q82WXzbSRNj28cG2V23ja36fxVj6NrEVv/a373/ljInlyPuidfk+Ztu7b/wDEpWjp1xL9mu9Ql1CO0tN6wQ+Wm1ZW/u4+9t5/8cpgUNYt5bi4i8q08r55JvL2bmdunG35fvVrW1vLqHlSxS/6XI6wff8Al3fMm4H/ANlqefT/ALPbzS+bceVsbfJ8v3R6/e2r/s7aTWNY/s/zoYtPt/sm/f8A6QnlNt2Y3fKu1W6r/wB9d6AM220/7R50UV3JFLH87/Pu81huzjc3zd/8/LWpp+of6R/aEun28sUb7Ht/9RK7Hpx/tMf/AEKs/TtQi+zzeVNcRXf3PtHnsu9uAGwn+z8ordH9k6hcReTN/wAebs/7x/vx7clv4t25j/F92gDJt7e0+0RTfZLOLzHZ3t43byto27Vx9771bmoahd6fbzeTFJdxb1hhkjTayKdh2gNu2r/6CtUxp9pcaxFd6hNJaXckO97fY0UTyf3vmX2/9B/3au6dp8Wn6P8A8TCaTyo5o3h/csqpj72T/D/u/wB6gDkL/T7u3/dS+X/aG9XS3/uKd3yhf++vmar9tp9pcafN5v7r+5/z1l/2f9nd/wDE0viD7J/aEX9nxSedJ5z+Zvbz0ULjp+ed1WNOt9Q1DR7X7XF5VpHu8+43+Vv/ANr7vzd6AOlGoXej6P8A6J+6+dnmkuH82XcF+7/d3f8Axa1k+HtQ0+41CLUJftFpFcJI6faH2qjFs8f98n7v510Qt/8AiXxRReXFLskm+zyO3lbT1aT5tu7+H5qw9Gt/+JhNLqsVvdyybUT7ytb8YGf95Qfu/wC1WcmBHqHii0uNQilhikiikfYkf3Z9wZ/mJ/2m/u/36vW+oXdvrF3Lonl/2fv2f7W0dfu/7v8AFUOoafaf2x9kiit5bu3g3p5m5tkfVW+997d/nFP0bwdp+saN5P2u4/d7f3m9VXcN3zbV/wCA/wAP92nFgao+yW/7393dyyIyPHcOrbGPJx833d3+zWXPcRaeLu7u/wDS/nXyLePdt9Wy33f7tYVtp8VvqE32S0uNQit/3H+j/wADHlfvfN/D8v8A9lUPh7wdqFx513/qot/kJ9onZWRSybn+X/ZqwG3/AIo1DxBqE13+7tLS3dUSP7uzH3Wz/wABrD07T5bjydQtIvK+f5JJEZYnU/wo33tqruX/AGmr0wafLcW81pFNb+Vb7dklv+8dG7sB/e/h2/e3bqm0a4iuLfT/ALJ5kNpbuuyTYyxP26fe2/Nu+agDzXRre7/fQxTRxeW7edHJt81/3gH/AAD71dxo2ny3GjzXf9o+d8+yeTyV/wBIjC/dX/Z/2qm07T4dQ1DV7uaKO0+8iXEf71d23Cs/zN/u7ajuPO/5B+nxSebs/fXkjqqox/iG9loAqad4Xl/ffZIreL5/n8tG27fm+7v+q/8AfFYmjah/Z9x9k+y/ZLTfH53yMrXEn935tyov3q1La51DT9Q0/wA2K4hhuNu+8knXb97j7jfT+Kq2oXFp9otbv7Jql3LJuT94+35fnK8/71AHQ3GoaTcXFrD5v7r946faIP8AVYYbsH/9qs/UP9I0abUPN835JEgj8ny/m/3v/HWZVrI1DUNb+zzRatqEdpDcbf4Ny+X8x2/3dqr/AMCrb07wtd6xcTQ2k3lfuGT94gaJI/Mwdyfe+4tAFrwdqEWoW/mzf6Jdyfcjt33KjBf7zL87fL/dqjcXGoXFx9k/eXct4jPPHGisr/Lncu3+L7vzbf46UeH7TUNQ/tHSZfJ8t1d7i3faqZViy4T7nyipv7PmFt50X2iWXf5DySPu2f7Jk/75X5fu9KhIC2Lm00+3tJpfs/myIu+3t32tuPzMx+b2/wDHKyhqH9oaNNp1pqFvDp8dkqT/AD7l9Gxv+827+Kr2safFo9vF5VpcebcOzv5k37p26bm+Xc/8Py1yPijT5dPuJtJl/wBE/cLOlvbv8qNtHyqfvP8AMxY/d+/VgW5/N1i4MU0Vv9kjdnS3+7sX+9/n5q2dO8Y/8Sf7JaRR3fzx+fcRurM7Bvl2j/8AarzfWPEEun23lWn2yW73qjx26bYt3z/McNu2/wC7Wlb6hd29xFN/qZd//LRG2/e+8Q38K81nYDqrjWJbi40//RLiKWSfe8cj/M67fLZgE+VU2/8AAvnrcuNP1W3uJtQ1Dy7Ty08+D7G7fdDD5dqr93btrE8LXEuj6haSyxR/6Qkmz7Q7fd2/MzfL9f8Avv8AiqLTvHH/ABMIoovtE0siRwTR26Muxf76713bV+7t/wDHatAT+IP+JhcTS3enx6hqEf3I7N/3SRlMs2Ebn/gW2rNv9kt/skWoWnlfaHVLWOR90ryBkw391NzVhaxrP2jztQlivPKk/cWv2dHVdobG7/4r/gVSXGsRXFvaWksVxd6tI7QeZG+7Y3QKx3bfl3fd3bm/76plI2/3txcGLUP3vmP8nlzL8n3hs2/3m+8zf+hV4T8aPCF5ouoalfaNC82nRsXeJsM0OW+n3d1evT/8S+48rVotUmh3q6XF58qzMN+3n+7t/wBpv/ZaTV9Y/tDw/wDZPNj87z/30f8AfXb94lfv/wDAq5ai0GfEuuRSXdv++cGWANn3rk7TR5bqWSWRGWEH5V9a+g/H3gOAPNcWsaq5GWQeleWul0uVggMiglRgd644VLEG/wDDh7bS7u2smUB5/uMa9ltoVt0AYgMBXhOiaLrOreIbGWaJbSC1OVI717hNMRZxFx86rgn1rF6sDB8V6mUiZQeAK8T8Q3nm3LgHvXo3i7UdqSc15NeP5lw7k8VpRV5XAz3+8agYZU1PJ99qhP3TXcBN4Qm8jxvoEmfuahAf/Igr9Mra4u9Pt7v915t3HuSG3jfzVdd4w/8Aur93d975K/MHSvNXxBpxt/8AX/aovL/3twx+tfqN4f8AO1DT4ruWWSKLe2+P5mkT50+U7f8APz1ogPj39tLS9X1G88Nazf26eWs0lk80BPlqW2yInPf/AFn/AHzXlmqQTXW2NFyFUV9m/HjR9PuPhRq2n6h5l3Fp9qsyXFxt3RTbh5a/e+Vt391dzKWr5MtuYKwrSsrAVNC0dbdQ7j5q6W3g3duKp2q7sccVqwDAArzG7lWI0TY2O1TSfc4p80WORTDytShlIn5jVm3bANVJOGNSwNxXRHTUDyvw98PtW8UeOIvDOiWn2vUJJmRI/wCFF3feJ/hXbX6D/BX4S6b8KfC8tpDIZ9VfL3F4rbIrllJ2rhvupuXhq8n/AGZ7K1h8c6lKYrcXMkUcyF03Svtfayq21mXqrfL/AHK9/uLiLT8+b+6l/eP5mxfkXcTtO78a9OnK4nsQ6NqGn6h8R9K0nUIbjVpdi3trHbvtXTMXDf6QR/dZtse7+H7v3WavVfDvjSw8XJcNp8UvkwndDcMuIrmPLASxt3XKNXA6N4O/4Sfwf5NpL/Z+q3ll/Z76hH/r0t5HBmAP97bnb/tVkeHvC+lfDfUNP8NeCZv7Eu7zU5p7r7Yj3MctvE80cdp5jf6vcgmaP/rg396vVg9DjfU9D063i0/UItJmtLj928k1leSPuV1Iyyg/3l+7tb+H7tc98SPC9pqGjxfZIv3sc0z2Ucf3eJ/3i/8Aj/3a7kW+ieN9HtJYpo9Q0+R/OguLOZl2MOOJEb5f4l/76FReKNP/ALH8H+baRSah/Z+66e3kdpZLhefOX/adlaTb/tbao46tGNaDhI4HxD4P/wCEn+IsN5dq7W3zFSY/lL7Ymj/p/wB810HwLtb6w8GSWd5P9ojhuGNofm+S3ZUaNefY7v8AgVc7p/xJi8f3Gn2nw/8AL8QRR3UjveXCPBZpGLfCt5mz5vnO3av3vLb7vWvTvCHhqLwroyWMdxNeyM5llu5xhpGbkDHZVXaqr2VVFJKwqNFU5OS6m/GMIPpUi96Yv3RT16UzsIZ+mfQ1BA+y3YepJqxc8QOfQiqJY7MDuKBigg0rtsjZz0WmwQ8ZJoE0bSeXuw/YHvQA+2uVcA159+0Vqf8AZfwu1+bONun3TZ/7Zn/Gu4X5Z4+w3/1rxn9tTUf7N+C2tjdgvCIh/wBtHVamWxUdz84InBpZCTVS3fNWj0ry3udi2OZ1Yf6SaZDUurj99moITjFWiCY8GrtnJ2qkTxUlu+1qkRW16TPy17F+x/4YTxD8R5fNM6pbWMshaBwp+YrHt59fMrxbU23SGvpz9hrSGvtV1u7kX90LZbWQbsb977mH5RU0B5n4w8HHwT8cb7Roi4Ftft5fmLtYIwLpkf7pWvQZIwyt71J+0DYCH4v6LrLoFm1KP944GA0kZ2/yZagcnYa56iNaehnadxMD712dgR5QrjrUYmNdZpz/ALoVmjYmux8prImTzGx71rz8o1ZkK75SPegC3F+5i4qhqMxEZOa0Lh1SM5rCuZ/MLKelAGeuGYtnmmvFv5BqGVHikPXFLFKYzk9KAHZ8kgf3uK3PDz7Ljys8GsadMrv9elXvDspbUEz2rIsd4XX/AIl8fui1618M9P8AtGjGb5PN+0FE/i2MR97/AD/dryrwwP8AiXxf9c1r2P4b6cL3w0Y/N8rzJ5D5e/axVQv3f1ropbmFX4TorbT5bi3Mss37qR/3/l7tr+uM/Mq8bqz9f8r+x5rT/VS28LbPM3eVLlh8zVLqFx/Z9vF9rljllj2+THG+3f8AL94lf8steM+OPHEvjfUItJ8M3cn9oXn+uuPPVVSPpyP/AB75f4q7TmE8YW+ofE/X/wDhGdJ+z/ZLdFe91CT/AFFuv8TKfu7trfd/3atax8LvD9xb6Vp/9lW/2S3fe8d580+4bg24/LlG+9/31XZeDvC2n+CNHitIZbOX72+SzRoLm7baPm8w/K3zfw1mXFvaYiu7S7uLu737Et5PmaLDYH7z/wCK3K1UgMLQNA0OwEssei2FpdxIyQfZbQJHu2sPvlS3/fON3+1TBqGlW/2WW7/dWnzb/MRVaJtuOu3+7ha6vUPtdx5Us2rRy+W+yaOT5dnov91t33vu/wDfNQeIPD+oXGnxXdp9n8qNPnk3svy+4G75vu1SAyJ7fW7jP7qP+ypNuy4jm8pUjP8AEDub5t1TXFvqGnjyrTUJLT7Qjf6PIm2J4x1USf3vl+7S6db/AGjR7vzdK/495o0mjjRGXyTxuwf++fvVb07WItQt7u0l0q48rYzpJJPuXb2bAZcfNtZvm+WmBjDT7u386LUPtEv8cPlvu2cf7LfN/wAB/wDHa+c/jh45m8X6/Fp/nebp+l/u4fvfePX738X8P/AK+g9Q1DT9P0ebVf8AQ7SW3dYfM2N5rsRkrldv3v8Aa/2q+S5pvtXiS/kmPJuHfP8AvN/9ehIhux9bfsS/FCW28UWvh6KX91JZbJrf+F2GAHH+1tO3/gFfctx8oJr8g/B3jG/+FvjXTvEOnFZvskgcw5x5i5+Za/S/4R/tIeCPjDpdsdM1iG31ZYwJtMvDsmU/7v8AEP8AaWtVsQmd8b0gkVz3iu3e7sJ4V6PGQa25gAc15J8Zv2jvBvw0sJ4XvYtV1pRgafaSfMPq3apaNUfM0nh/+x/h2dQ0ny7TxL4X1O9097i3/dSXaxtnbJ/E25T/AN9V6No2o3eoafa63FdyS2usJHN9n/hTvt/i27vvbv71fG3jX4j6p4r17V9Ry1hBfXj3j28UjbFkcDLf+O1vfCX4w3fhf/iU6h5l3osj/J/E1u395f8A4mlYZ9W6xqEX2iKW7i86K38zZb79svmdT/Eq/NTtG8QXeoaPd/a9J/s+02L51x8qq8e7/e+v3vzrJ0/UIvGH2XULu7j1XT5H2Q6hJu3SqOjEf7Lfw7f++a6G40+W30+KW7ijtPs6eTB9n+9uLf7H3v8AgP41jYCO2+yXH2u0l+0SxfwXnyqu723f8BqK4uPs/wBltIf3sXzJN5m1mduAV+Xbu/3l/wBn+7VAaf8AaPO1CW7jtLTfv/0f7rsOP4vurVrWNQtPD+ofvtQk+5DD9os3VvN/Dd83/fX92qAmnt4tY/df8elpHt/efMsqfh/EtY4+16h50UsVvFLHtmeO4fyp5V/vB/4q2/EFxoniD/VXf723RUm+favP8J2ttR1bbWDP4fl0/N3/AMfd3/rnt7i1+4o4Vwfur/vbl/4DQB0lxcfZ7iKKXUI/N+4kccDTy7duRz8u/wD3tu2qVxo+n29x/rrjUJdm97eRGi2L2YbflkXd0+X5ah0a31DUBFd/2Jcafd/Mk1xI6/vYyuNo9P721f8Ax6r+oXF3cW8U32v91/Bb/dV23fLuG35WWgCG20/Sbe3m1v8A4+5d/kpcR/xtuT5v7y/981a/4Rf7RceVqEX9n3cfzpcRvuZ88hhu+Zl3fKVaq+jXGof6XLq2kxxRb1dPs7+b+77N5ir8q7vl+Zd26tPxBqH9sf2VLafaPske3/pq34feoAzLbWP9Hm0+70/7X5flol5b/LvXupfd8rf+O1WurSyXUYru0tXs5I9vF5N5hb/ZDM3+fWqeoW93qHnS2lpcS+X/AM9J3i2fht2t0/76pBb6hqGn+VLaXlp5fzvJsTynUdV+98rf7qr9aAL40+bxRcTSxTRxS2/345PlWXHqW+63oy1f07R+JvtcslpdSeW6R3G3/voFV+b/AIC1ZenafLcafN/YkVxLqu9kf7ZP5rXCnIKZT7jc7R93/gVdH4O1D+0P+JTdy/2fLp/3Le8hZp0/2gfut7/w0Eoybj/ll5t353lzKn2i3mbzU9Od3zL935dtbWsXF3qH/Evl/wCQf9/947Mzt8v8f8TVa8cXGlf6rytLli2f3G3O398YVm7/AN6vONQ+1+KLibwzaatJFaRwx/apI38qW4Y8qg3fLt2/NuoKMLxhbxeKP7W8QWnlyxaG9ukNxHN8z+U/mSZO3dtb5V3f7FfPHxq1a11r4i6pe2abLeTbG3+1Kqqsh/76zX1H4w1jSvBHg/UYpfs+nw/YpoIbOP8A1r5RhtG37y7jz/DXxpqBE88UR48tKCWZe3FKBipdntSbfarENC0badQBmkWfVH7Pmn/Z/hs8v/PS4P7yN2Vv91q9EGoRW/8AyELu4hl/j8tNy7e2Hrkvg/ot3Z+CNIEV1GI3t8/Z/vNuLb+f/wBqu2v7f7Pceb+8i8vd/rPm2dj/AHt1c7EZXjv4e6H8RtLWLVrMpcLH+5urYAOBnjnsfZq+UviJ8I9Z+HNxvuAbrTZGxDexrhWHow/hb2NfYf2f+z7eKHMH7z/b27VrL8aaSPF2kXWi67HFLZzFlgcj5w38Lf71VHQbPh0HFOExrb8b+DbvwLr02m3TedGDmG4Xo69vxrBAxWyIJgcipEG41FGOtXLeHjNWIdGOKlUGhRipFxUkn6S6do8Vvb/vfLu/MfYklujSSpIOijd/Cv8AerLFvNo/lS3dp5UsnyfZ7if5un3v4VZf+A/99Va1jUItP0+LypvNlk+/HG+5Uz1z838Nbn9naVrHnS/a49QljSP+8qou1v8AgO7/AHd1cKlcswLfULTT7iKWWK3u7uRGT927fumD/d+b8a0La40/T/8AkHwyf2hI6u9vcblWJTuy38Xv/wB8VW1DR7S41C1i0+XyovO+eS4faqLxlfvfxf7VVtQ8L/8AEwu/sl3+6j/11xGjKqYGfmLfX5VqwKmoXH2/UIrv/Wy722SeT8zqFGPL+b7v+c1MNP8AtHnebF9k+9vjjh+/8uNzH/Zb5qseHtQi8L3EVpFL9rl+VPtEn71U+b73+9zVr/hH9W/4SC0+yah9ktJPnmjuIfNifLN83/2LNU84Gxp1vLp+n/a4v9Li+XZ8ir9WJ+83/jq1nXHjC00/zruX7RL9o/c/Y7NGX5dv/PRV2r/49WuLf+x9Yiiu9Qk1CKRFmTy0ZWTPbb91f93/AHa5i4t/s9xNqF39ol8vc6W8cKxfN2Una33vm/vVSdwH6xqEX+pl/wCPv+COP97Ltx91Nv8A8TtqxbeVp+nmHzvtcNv87yR/69G2tlXP/wAV/cqTULfT7i3Np+8tbu4+f76tKkf90/NtWs+31CXULiL7JF/oke55ryR2+dgPuqq/LTYD9OuLvWLeLyYpLuKN/ns9+1kX5vmJ27v4qvXGny6Bb/2f5VxFLsXZHGjMqKemD/47R4WuNQ1i3u/skUnlRo2+4jTarqW7lm3MzL/eqcXF3b6fNLLF9k+dU+0SOzM69ocbfmZfvVaAz7i4tLe3iiiij83zv+Wm75GP/TNflX5aW4/0j91FaSRRSOzzXn8KL/ez/F/u/d+7WvbaPafZ/wB7d/ZP+niTcsVv/tfd2s7VhjR4re4iiiu/3XnM/wBzz5ZWLccLuX/vmmA6e3iuNQillij/ANS0CfaEZldtzfMvy/e5X/ZqDUPK0+3iu/Kku/3LOkmz90knTr3/AN3+Fa63xRp8tvqBlu5pIrT+CPevn3eFBVT8zN/D/Dt+WuQn0eXUL/8A4mF39k8t2RPtG1d6j+H5/lZf4qBon8PXF3cW80v9n/a5Y3Z0vLdHVUb6syruXa38NPH2u3uP9Ei+yfO2yPz/APWt8x+f/a4rRt7iL7PFaWmoWdpLHu/eSJ5SovH/ACzX5m74+n8O6odY8P8A2f8As/VtJu/tcVuke/UJEbc+FbOAzL/F/wCgUrFoNQ1DUNYuIv3UkUuxU8vezSu30+6q/wD2NM064u7/AMr/AI+IvMTyUt/li2Nj7v8As/8A2fStPRtY0m4t7v7JFb2kvy/vLiDyo0zj5jJ825tx/ip3iDxB9o0+1i0+b97H86SfLFszu+c42/L/ABfLTWgyhcaP4Z8L5i1DUP7PupEZ54/kVUYjIXO3d97/AGv/AEKszTvsmoW93d/6R9kjhkSb7Pt815N+du/5m3etIPB/2f8Ae3cX+lyfOnz+az5wNx+Ztjdfu/7NW7bR9b/tD7JaReVp9vM2/wAv5mmkHp/47QBILeL+0LvUPN83T4/kez37v4Qdsh+9947drbqh/se0t/sv9oaf9kl+VHuPP2qkZcfJ/wB85b/ef8Kk07T7vWNYii0//iXxeS3neYnlTu249C3/AAH5vmq6NPtPE+oat+9+13fnRo8e/wA37PleXJ3bVXcPpQBY063tNY1i7tLSKS70q3dXS3t08qJ5gMhnC/d+bNXb/R/s9xNd6hLbxRfKiR/dbb82VB/4DWpZ+G4fDumTQ3F8Zi8gJKq5SJeTyyt/6F6/3VrzvxB4gi/tCK0tLS41D51RPtm6JUbGN3y/N/tfw/fagDe/4SDT/FFvN5M1x9r2b08v5llUs3Zv944/Oq2sahFcW/2SK7+1/wDTveI/mp6fw/e/4Fu/8drF0+31C38QRRaVaf6z7+obNyp/sHdt9f4vl+Sup07w/pNvp/m6hqFvLqtwnkwSSQbZUUNy5K/KzNj/ANBoApW39rcxS/6r7iW8ny7Fxyx/i2/7TVpado/9r6fNaWk0d3qEc3nPJJOzQO3Xbj+7t+b/AIBWdrGjxf2h5Wn2moXcv7vZcb2bt+8Ynd87buu7dV7RreLWLf7Jd+Z5u/yUks7p13/PgsSu3a3/AMRt/ioAy7b+27fztP8A7P8ANijmZP7qxf3mP8LfNVL/AIqbT9Pmi0/T/wCCN/3b/fzxuxtb5tp/2a9D1jwvp9xcRTTTSRfY02JHbzMsSKF48zbu3NWbqHjD/R5pYoo5fLm86C3+6u4e/wB7/a/h/hqWgOTttZ1bT7ia7h0n+0LuT/n3+Zkbb8ufl9/738e403+0Lu48QaTd6hF+62M88dntiZJN33SE/wB3+L/x2qo8U6jqGoXf9nxebF9qX/Q9jNvk3fdOxf4c/d+X3q/rGn2lvp81p/ZP/E12N+7jTdbRfMwO5m+V22ncy/8AoVJaAXbj4gRW9xd6daReV5c6/vLh/KZ/4OAn93/ZrWuNY1DWLc6faahJ+7gke9vLhF+TLD5l2M38O75f9j/gVcF/Z+k29vFNaS/vY54XmjjTbsYfwj5f+BN8rfw16J4W0/7PqF5qEWoXnlSJvS3uEbbuPH3WX/gX86sCS40+a38PxfZLuSWWT/URybdzru/vov3d3+flqrrHh+Lw/bm7+13H9ofL5EcbtLFb/KmVXd/9jWxbW8ouJvKtJLv7O8ey4+8u4LllXO1XX5du7+89ZPij+1rjyvsn7q7t51nmuLh1WJ8t5aoNvzetAHL2/iDUP+JvDLdx/wBq2/z/ALz/AFT4wG/do21drbvvf3K1dGuPE2oeHtRu/Kt5ZfP+ez/5a/e+6f8Aa2/+h0lv4Ght9P8AN83zpbhPPn/f7WfK5+b+Jv4VXcy1Z/dW+jRXd3/ol39q/fx2/wC6idT/AAFdu37y7f8A2agDKuLf7QIovEGoW8UUbqn2PYzQW/mSNjndtd9y/Kv+xWvp32TT7f8A4l93JdxefsgkuH2xIwwdyt/u7VZqu6d9k0+3m/tG0+1yyTq6SW+5v3nRcb/l+Xj7qrWXrHnahb/6q4tJdi7/ADNu58Ljltvyru/ioAz/ABPcRfZzaS6hJ5u+PZHHDulf5s7t7/L/AHl2r8v3q1vD3iGK408/2T5n9o3Cf8fFxti+U+n8X/Av9ipLjw//AGfm7i0+4/eQbEvJHWdkm24+6/3Pu/8A7NS6f4fh0e3P2uWPzfPWePzNu5I5N21f9v5dzf3dyUAWNGuP7H0/zfOjl8u9/wBZbpta4yv3Sv8AG3zbv+B/3fvadt4git8/avtHkyTt5H3Wl/8A2dp+Zvm+5VvV9Gi1DULW7tJZPskbrG8cabmdiwJYs/3FVR/45iuKn0/7RrF3DaXdvLDsZEkvLXyp3k2/Nt+X5P8AZ20AdB441D7RcRSy/urS4haBI7iHzYrdt2Gb/wCy/wBiuL8QeKIri31HT7Sazu/u/wCkbPKZF6df4Pm3VtXHh+7uNPmli1Czi8x/39nJ/qolOPlOz+L733ai8PafNbzxWl3pVv8A6iTyI403Tv0+9/3y3/fdYtAZf9ny2+nHyv3V35Hyfdl+bdncw+b0rMuPC93p/nah9k8qXeu+SSFli+997/b+7u+X5a0dYt4rfxBFq01p5UVu6wJHb7mX7zfNtX7/AEP8P8ddbcXH/Cb6fN5X7qWOZdn2iZVZ49vy7R8yp8y7apAYFxcafcagdJ864mu5Ek/gdVePAO/b/d3Z/i20DUZbf+ybSL/lonkTXEaIqxLtz/rP460hqGk6fcaj9rhuNQ1CNNnl26Nt53ZXP3dq5/i/uVyOseH7vR7jUbqb7RL5b73t/wCK3jP8K/Lt/wBqrQHQ6NrEWj3F3FL9n82ORrWCOTduuF67g38fzN92q9xb/wDCP6NFqEvl/wBrfvnTzE3MjF89N3P8P+ytUv7QtLi30/8A497Sb926RyJ5sT5Zj13bmZdy/wB2tPw94o/tDULv7X5f9n7/ACEuI0VfmGPn+b7ke7Hy7qZSKFxp+rax9s+16jcWmoW6M/2y4Tzbl2kZhEgjf5U2/K3/AHzWH448UQ2GoRaf2jT/AI+PIWJn/wB4LXe21vF4gt/J1H7RLLHBveSOdVbzOTu+X+LdivOviBo/9oeIJpZfL+4v7u3+6n91f97bt3VxV5XVhnK39xFf/vf+Wdcdo/h+LUNQllii/db2rVv9Iu4P9VL/AOzLXQWtq2nWVvGvBQLmvOSsBBaeH4rf5lTBFZXiK5+yDaWwPSuml1iCxjIdstivL/G+vkSk7cgnimBw/i/VzLcMinI9K4+fIyT0rYviAWlkOX61jSgykufyrrprlRBUY5Ymon+6akPeopOFrcC34NtmvPHfh6BI/OeTUbdRH/ePmDj8a/SHTtQluLebStQtJIru33TJZxv5UW7c2VH3mX5VLV8C/ATSYtX+Lug/aHCW9tM107MyqB5aM65LcfeVa+9bf7V/Y/8AaHm/8TCR4US3kdImSQ4G0/8AAd2K1QHnf7Tmv6JZfDTUbXTo5JZrm7hje42NyfMJZSzfxfKa+ZLQZgr3/wDaduLT/hVslpFFJFdx6jDM/wBoT5nj/ejcD/vCvn/RXE0SdwRn9K5cQBq2UOVrTihqO34UVbU8V55ZIE8xMd6ry2jQAsanWcQ4JqprWqhLfjvQBmSSBicVJE2FNZltLvJq8rYFWB3Pwf1RtN8cwXHmyQgwSxs8S7mA2Zzj/gNfTGseTcafay3UXm2n2Xfa3G/zJZZCG+b/AGdu3/x+vkLw5qLaXqcFyp+6wJ+lfV41iLUNH8qW0+yRb43tY40X97nHzkr8q/e/76r0cM7ysJ7HqngbzbbR7D/cWue8caf/AMSfXPG2iaheWun6hpnk6hb26NK0WHwbqFP+e0ambd/e/wCA/N2PhuER6faoBwqL3q7cafd6f/ZVppMUcWn/AGpvtUf8PlkMdv8A30RXuLQ5HucX4W8caJ4X/s/RP+JXF9sspNd1PUNP/dWKQ9I5v9lpsBtvtJ/wL1q2rza3+G3hnR9Qi8TWnl2mn27yXs0cb/uH8uERx8f3I9pZV/hPNa/wl1nVvFWhzeJdVzFFrMv2rT9PU82tmQBDuH95l/eN/vbf4aCLHTaRo1j4e09LHTrS3sbVGZxDbRCNdzMWc4HcsWb8auL1qhoWv6d4o0xdS0m7W+sXkljSeP7rmORo2I/FDV9etAWJl6U9elMXpT16UFEN4f8AR2H0qsFBQfSrF4cQmqyH5RQAnTNSgRTw+hplMHFACLB5H/TXrXzh+3hfTN8Jru2iG5FltWlPovmnH/jxWvpe2ni714T+03p8eteGvE1gF3udMlZR/tLHuX/x7FTLZlR3PzVtqu7wFqjDxUrvhTXldTrMTVOWJqtF92rGpc1Wi+7WiIJgc09elRr1qRelMCjfffr6t/Yk8238M+IZrXzDNb3UTun99dsny/dbd1+7Xylfffr6m/YV1mW2Pi2xjPUwTAf7W2QJ/wAB5pAemftK6J/wkXhvR9RSDzr7S75ZJ5on3KkTfu2U/L/e8r/x2vHW5Q4r6R+IFvFceB/E0sX+tjhkR4OW2MfX/wCKr5vh5gJrmmzWCKcK7ZPxro9PP7sCufjH7yt6w4AFZmxdkH7s/Ss1G8qQmtSQfIax74+Xk0ANvLwOCM81n/KfrSbDIxbtUbRsj7u1AC3EQaM8c1mEHODWvI4KVTljDcjrQA97hPs6xYy3rUuiOFuyBw3rVSOIKct1q5pu1bksOtZDuW/DCn+z4v8ArmteleD7g2FhHLFN5V3HIzw/PtZ22/7X8P8AwGvPPDAH9nxf9c1ro9Q8cxeF/C5h/d+bv85PnPmbvp93b8v8VdFN2MqhJ4w+JGoW+oafp8UUc2qyfIlvburL0yW/2tvP/fFbXgb4TReD7f7X/o//AAlcfmTTXkbs32v5myuw/L6YpPhN4OtP7HtfE3iD7PLqFw++CTUId0tvHjj/AHP/AK/+zXaC4l/ti7u5bv8A4lXnbPLt4Gn+0ZxtYbdu7sv3f/suqLMDmv7Pl1DztPhm/ex/P5cibbnd1P7v7u37udrL9+sr7PF/aHneVJaS3G1H+dl/d8j/AGvut/6HXU+INYtNPt/Nl/0SWTc8Nxb7fNeOP/npJ90f7v8Ad3Vy9/b3en6xd+Tp9xNafK/2j7bu3qeRx/D/APXWtUA7TriW3/0uWL7XFvksk+z/AN7d98llXa3+9WxqHnafbxSyzRxTb/Jm+zp8qN24/vf+y1i6hrF3qFxaxReX5Vx9+ORF+djwc/xbf9qm6d9r0/UJtPilj82z+eG8kdpYrjt0/vfw1SAv/wDE21ATRSzf2h+5+f5Eb93wNu3/AMerF0+3tNP/ALRi1CL/AFaKiWcm5t6/0/8AHq6efUPs+n6hLL/yEP4JPIVVf5vuk/73+flrmtQ1D+0NP0/zf+Jhp8f+ujkdFnTH/PMq247fvf8AAKoDxn4s/wDEv8P+VaeZFaSXWz7P/wAstw3dPl+9/wACrxPULET/AL2M/vf517T8fTaadoWjafaTSSmaaS7k8z+FRlFrw6e5Izg0GBnveNF8sgP+69QPdHOYT5Z/2KuSOsylZkD/AF+9VJrJYyTG3H93vVCNb/hOvEZtxbnW9QMP9w3DYrJd5LmRpJXZ3Y5LMck0ynUFIntrjIli771ff9Kv6dqMthPLFEf3Nwmyb/bXP+191v8AarJ6e1SZi8j/AFtBofQvgbxRd+H9Qm0nyvtenyTQpdfY9rM90eYbqH+7uXarbe9e4W2oeJtPtzp/2vyvnV3j+aVosc7jvVcbl/u18j/D7T7u4t/9Eik82OaF3kt32s8O8ZU/7SsqMv8AwKvqqfWIrj97aTfvdkmyOSZtzttHV2/i+7/8StQ9ANIXEWoXBtNP0+3li2K73HktKrsV+6f8/SqWoeF/7Qt7X/hH5Y/NkeRJrPfugRRjLAyfvN3+ztpNG8URXGoRSyzeVFs2f6lol3bfvY/h/wB6qltcatqGZf3dpL994/trMqY/jyv96oeoGpp9xp9x4f1aKKaSWWN2+1eY6tsYf733l/2l/Kqmnf2tb283m3cdp+52eZJO+513YKkOqqy7f/QOtZ2oXH9of6JqFp5sUaKk1xbw+bv+bhs/eTt95f4+lP8A+Eg/s/T/ACv3kUVvN/rN7Sq+Pf8Ag+WhATjUPs/leVN51pI/k/Z43VV2j03L8zf7u5vnqW/uPtGoRafNp8lpFJuheT5tz4wRkblbb/tbd1c9rH+j6hN5v2j7JJtmmj+bb6hsfxf71dT4e1pJtOU3uZV3Li4SRBKn93G1v4f7q/epgao1CXT7f91aWf8AZ8abJrjY8v7wdP7zfd/h/wDsa54ahaW+ZYruTSrS4Rt/mPti87+LA3bl+792mah5v9oGX7J5tpJ8/wC73RS8bht/yzVJp39k3HlRedJafe/dyfvVRv7yF1/u/wC8v/fVAGfcf8TDyvK1CPzo/wB8kkbtuT+D7jNt21vaN5tvnyovtcscPyR3EKqz5X5sjd8q/wCz/sVFbXGn6fqEX+lyXcW+SZPs6O0Tr/d+6y9vu/LV4eOLTR7iaG0/0S73ts+0bWi2hf4Ay/e5+7/vUAYOn6hFp+sTRRWlvFLv/wCPiN9sX5r/AOzf7PNdHf6xLrFx5v2S4/tD5t9xHA3kOu3nlfvNWFb6xaeINY1aWWKPypEVJo7h2ii568N+H3fl+etnTvD8X+l2mlSyfvIdn7zZF9nUbvmH3dzN/tf7NAFT91b/ALr/AEe7+0TeRNbxoq7IyOz7lZen/wBeox4X0/ULibzYriK7j/5eI90Uqfiu35fu0v7r+0DLdy3FpLZurp/y13t3xu2r/wCy/e/vVzfxA+NP2jR/sn/MP3s76xHB823HMMZ/if8A8dWgDzP4gXEVx53hnSoreL7ZdLDNqFw6tvw284kf5tq9/mrxbxhp1ppPiu/stPulvLSF9kU8fRxt610PijxRFcax9r0SWS0i8lk8vfu8pTxsH/AT977xbcawBp8MGn+bFLJNL/HVJXMXoVxYlrZSvWqs8MkBG/pWi/mfZw6dBVC7vTPhG6imBA33aWMcUP0oj6Uiz7W+GVxLceANI/ff6u2RP+A5OVP97bt+7tro/wC0PtFxN5s0d38m9I/veb8vOP8A7GvNf2fdbu7/AMDbJzIY7GUxp5ci7sYDbWH3tvJrv9Y0+a4/s/8A5dJY93+sdWV17f53VgWT6fo93cav/wAs/K2b3+dWjRv71LceH/8AT/Nu5pPv7/MjdpF47Csye3+z2/mxah5vyb/L2Mzce6/Mvy10dtp9rqFvHF50kUvzOnz7VT6f3v8Adpog4H4tfCyDxz4f/fKsN3GGewuR/e9D/stXxzNbva3EkEoxLGcMtfoLp+n/AOt+1Xf2vy0+TzP9X7f71fO37Q/w4NxAvivTYOQipeqo+X/Zk/z9aFIDwaMVbjOBVSOrUfStgJh0pwOKavSlpgf/2Q=="],"theme":0,"title":"MERRY CHRISTMAS","isGestureSwitchEnabled":true};

        const CONFIG = {
            colors: {
                bg: 0x020205, gold: 0xffd700, red: 0x880000, green: 0x004400,
                iceBlue: 0xaaddff, white: 0xffffff,
                pink: 0xffc0cb, pinkDeep: 0xffb6c1, pearl: 0xfff0f5,
                orange: 0xff8800, black: 0x111111,
                fireworkSilver: 0xffffff, fireworkGold: 0xffd700, fireworkGreen: 0x55ff55
            },
            particles: {
                count: 2300, dustCount: 1500, treeHeight: 28, treeRadius: 9,
                snowCount: 2000, snowSpeed: 8, heartCount: 1200
            },
            camera: { z: 60 },
            gestures: { palmOpenThreshold: 0.25, sensitivity: 12.0 },
            text: { string: "Merry Christmas", size: 10 }
        };

        const STATE = {
            mode: 'TREE', focusTarget: null, currentPhotoIndex: -1,
            currentThemeIndex: 0,
            gestureDebounceTimer: 0,
            isGestureSwitchEnabled: true,
            scatterScale: 1.0, gestureBaseSpread: null,
            hand: { detected: false, x: 0, y: 0 },
            rotation: { x: 0, y: 0 }, spinVel: { x: 0, y: 0 }, time: 0,
            wasPointing: false, palmCenter: { x: 0.5, y: 0.5 }, hasPalmCenter: false,
            // üåü Â≠òÂÇ®ÊâÄÊúâÂÖâÁéØÂØπË±°
            toppers: { 
                star: null, snow: null, heart: null, 
                snowOrbit: null, heartOrbit: null, // Ê†ëÈ°∂Â∞èÁéØÁªï(‰øùÁïô)
                goldRibbon: null, snowRibbon: null, heartRibbon: null // Ê†ëË∫´Â§ßËû∫Êóã(Êñ∞Â¢û)
            },
            starHaloMesh: null,
            textModeExpiry: 0,
            letterContent: "Âú®Ëøô‰∏™ÁâπÂà´ÁöÑÊó∂ÂàªÔºå\nÊàëÊÉ≥ÂëäËØâ‰Ω†Ôºå\n‰Ω†ÊòØÊàëÁúº‰∏≠ÁöÑ‰∏áÂçÉÊòüÊ≤≥„ÄÇ\n\n(ËØ∑ÁÇπÂáªÂè≥‰∏äËßí‰∏ä‰º†‰π¶‰ø°‰øÆÊîπÊ≠§ÂÜÖÂÆπ)",
            letterTyper: null, letterStartTimer: null, letterLastTriggerTime: 0,
            musicData: null,
            environmentGroup: null,
            currentInputType: 'MOUSE' // MOUSE, TOUCH, HAND
        };

        let scene, camera, renderer, composer, clock = new THREE.Clock();
        let mainGroup, starGroup, bgGroup, photoMeshGroup, fireworkGroup, particleSystem = [];
        let galaxySystem = null;
        let snowSystem = null;
        let heartSystem = null;
        let fireworks = [];
        let textPoints = [];

        let handLandmarker, video, drawingUtils, canvasCtx;
        let lastVideoTime = -1;

        let caneTexture, snowTexture, heartTexture, giftPatternTexture, particleTexture, matLib = {};
        let glowTexture;

        const _tempVec = new THREE.Vector3();
        const _targetVec = new THREE.Vector3();
        const _invMatrix = new THREE.Matrix4();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        async function init() {
            try {
                initThree();
                setupEnvironment();
                setupLights();
                createTextures();

                await generateTextPoints(CONFIG.text.string);

                createMaterials();

                createGalaxyBackground();
                createSnowBackground();
                createHeartBackground();

                createParticles();
                createEnvironment();

                for(let i=0; i<400; i++) fireworks.push(new FireworkParticle());

                setupPostProcessing();
                setupEvents();
                setupLetterSystem();
                setupInteraction();
                
                // ÂàùÂßãÂåñUI
                updateControlPanel('MOUSE');

                initMediaPipe().catch(e => console.warn("AI Init failed:", e));

                if (PRELOADED_DATA) {
                    importSceneData(JSON.stringify(PRELOADED_DATA), true);
                } else {
                    hideLoader();
                }

                const mainTitle = document.getElementById('main-title');
                const subTitle = document.getElementById('sub-title');
                if(mainTitle && mainTitle.innerText === "") mainTitle.innerText = "Merry Christmas";
                if(subTitle && subTitle.innerText === "") subTitle.innerText = "To: My Dearest";

            } catch (err) {
                console.error("Critical Init Error:", err);
                alert("ÂàùÂßãÂåñÂ§±Ë¥•: " + err.message);
                hideLoader();
            }

            animate();
        }

        // üåü Êô∫ËÉΩUIÊéßÂà∂ÂáΩÊï∞
        const CONTROL_INSTRUCTIONS = {
            MOUSE: [
                { icon: 'üñ±Ô∏è', text: 'Âè≥ÈîÆÔºöÊï£ÂºÄ/ËÅöÂêà (Â∏∏È©ª)' },
                { icon: 'üñ±Ô∏è', text: 'Â∑¶ÈîÆÊãñÊãΩÔºöÊóãËΩ¨ËßÜËßí' },
                { icon: 'üñ±Ô∏è', text: 'Â∑¶ÈîÆÁÇπÂáªÔºöÊâìÂºÄÁÖßÁâá' },
                { icon: '‚å®Ô∏è', text: 'Â∑¶Âè≥ÈîÆÂêåÊåâÔºöÊñáÂ≠óÊ®°Âºè' },
                { icon: 'üìú', text: '‰∏≠ÈîÆ/ÊªöËΩÆÔºö‰π¶‰ø°' }
            ],
            TOUCH: [
                { icon: 'üñêÔ∏è', text: 'ÂèåÊåáÂº†ÂºÄÔºöÊï£ÂºÄ' },
                { icon: 'ü§è', text: 'ÂèåÊåáÊçèÂêàÔºöËÅöÂêà' },
                { icon: 'üëÜ', text: 'ÂçïÊåáÊªëÂä®ÔºöÊóãËΩ¨' },
                { icon: '‚è≥', text: 'ÂèåÊåáÈïøÊåâÔºöÊñáÂ≠óÊ®°Âºè' }, // üåü Â∑≤Êõ¥Êñ∞‰∏∫ÂèåÊåáÈïøÊåâ
                { icon: 'üëÜ', text: 'ÂçïÊåáÁÇπÂáªÔºöÁÖßÁâá' }
            ],
            HAND: [
                { icon: 'üñêÔ∏è', text: '‰∫îÊåáÂº†ÂºÄÔºöÊéßÂà∂Êï£ÂºÄ' },
                { icon: 'üëå', text: 'OKÊâãÂäøÔºöÊâìÂºÄ‰π¶‰ø°' },
                { icon: '‚úåÔ∏è', text: 'ÊØîËÄ∂ÔºöÊñáÂ≠óÊ®°Âºè' },
                { icon: 'üëç', text: 'Á´ñÂ§ßÊãáÊåáÔºöÂàáÊç¢‰∏ªÈ¢ò' },
                { icon: 'üëÜ', text: 'ÂçïÊåáÊåáÁÇπÔºöÈÄâ‰∏≠ÁÖßÁâá' }
            ]
        };

        function updateControlPanel(type, detectedGesture = "") {
            // Â¶ÇÊûúÊâãÂäøÊ£ÄÊµã‰∏≠Ôºå‰ºòÂÖàÊòæÁ§∫HANDÊ®°Âºè
            if (STATE.hand.detected) type = 'HAND';
            // Âè™ÊúâÂΩìÁ±ªÂûãÁúüÊ≠£ÊîπÂèòÊó∂ÊâçÂà∑Êñ∞DOMÔºåÈÅøÂÖçÈó™ÁÉÅ
            if (STATE.currentInputType !== type || (type==='HAND' && detectedGesture)) {
                STATE.currentInputType = type;
                
                const headerTitle = document.getElementById('current-mode-title');
                const contentDiv = document.getElementById('gesture-content');
                
                let titleText = "üéÆ Èº†Ê†áÊéßÂà∂Ê®°Âºè";
                if (type === 'TOUCH') titleText = "üì± Ëß¶Â±èÊéßÂà∂Ê®°Âºè";
                if (type === 'HAND') titleText = "üñêÔ∏è ÊâãÂäøËØÜÂà´Ê®°Âºè";
                headerTitle.innerText = titleText;

                const instructions = CONTROL_INSTRUCTIONS[type];
                let html = "";
                instructions.forEach(item => {
                    html += `<div class="gesture-row"><span class="g-icon">${item.icon}</span> <span class="g-desc">${item.text}</span></div>`;
                });

                // Â∫ïÈÉ®Áä∂ÊÄÅÊ†è
                let statusHtml = "";
                if (type === 'HAND') {
                    statusHtml = `<div id="gesture-status-bar">ÂΩìÂâçËØÜÂà´Ôºö<span class="highlight-status">${detectedGesture || "Á≠âÂæÖÊâãÂäø..."}</span></div>`;
                } else {
                    statusHtml = `<div id="gesture-status-bar" style="color:#888;font-weight:normal">Êú™Ê£ÄÊµãÂà∞ÊâãÂäø</div>`;
                }
                
                contentDiv.innerHTML = html + statusHtml;
            }
        }

        function hideLoader() {
            const loader = document.getElementById('loader');
            if (loader) {
                loader.style.opacity = 0;
                setTimeout(() => { loader.style.display = 'none'; }, 1200);
            }
        }

        function generateTextPoints(text) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 1024; canvas.height = 256;
                ctx.fillStyle = '#000000'; ctx.fillRect(0,0, canvas.width, canvas.height);
                ctx.font = '700 80px "Cinzel"';
                ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(text, canvas.width/2, canvas.height/2);
                const imgData = ctx.getImageData(0,0, canvas.width, canvas.height);
                const data = imgData.data;
                textPoints = [];
                const step = 2;
                for(let y=0; y<canvas.height; y+=step) {
                    for(let x=0; x<canvas.width; x+=step) {
                        if(data[(y * canvas.width + x) * 4] > 128) {
                            textPoints.push(new THREE.Vector3(
                                (x - canvas.width/2) * 0.1,
                                -(y - canvas.height/2) * 0.1 + 5,
                                0
                            ));
                        }
                    }
                }
                resolve();
            });
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.012);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, CONFIG.camera.z);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", depth: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            bgGroup = new THREE.Group(); scene.add(bgGroup);
            mainGroup = new THREE.Group(); mainGroup.rotation.x = 0.1; scene.add(mainGroup);
            starGroup = new THREE.Group(); mainGroup.add(starGroup);
            photoMeshGroup = new THREE.Group(); mainGroup.add(photoMeshGroup);
            fireworkGroup = new THREE.Group(); scene.add(fireworkGroup);
        }

        function setupEnvironment() {
            const pmrem = new THREE.PMREMGenerator(renderer);
            pmrem.compileEquirectangularShader();
            scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
        }

        function setupLights() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.2));
            const bottomLight = new THREE.PointLight(CONFIG.colors.gold, 3, 40);
            bottomLight.position.set(0, -10, 10);
            mainGroup.add(bottomLight);
            const spotGold = new THREE.SpotLight(0xfff0dd, 800);
            spotGold.position.set(40, 60, 40); spotGold.angle = 0.4; spotGold.decay = 2;
            scene.add(spotGold);
            const spotBlue = new THREE.SpotLight(0x4455ff, 400);
            spotBlue.position.set(-40, 10, -30); spotBlue.lookAt(0,0,0);
            scene.add(spotBlue);
        }

        function setupPostProcessing() {
            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloom.threshold = 0.75; bloom.strength = 0.5; bloom.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(bloom);
        }

        function createFrostTexture() {
            const c = document.createElement('canvas'); c.width = 256; c.height = 256; const ctx = c.getContext('2d');
            ctx.fillStyle = '#666'; ctx.fillRect(0,0,256,256);
            for(let i=0; i<80; i++) {
                ctx.strokeStyle = `rgba(255,255,255,${0.2 + Math.random()*0.5})`; ctx.lineWidth = Math.random() * 2 + 0.5;
                ctx.beginPath(); const x = Math.random()*256, y = Math.random()*256;
                ctx.moveTo(x, y); ctx.lineTo(x + (Math.random()-0.5)*60, y + (Math.random()-0.5)*60); ctx.stroke();
            }
            const tex = new THREE.CanvasTexture(c); tex.wrapS = tex.wrapT = THREE.RepeatWrapping; return tex;
        }

        function createHeartTexture() {
            const c = document.createElement('canvas'); c.width = 64; c.height = 64; const ctx = c.getContext('2d');
            ctx.fillStyle = "#FFB6C1"; ctx.beginPath(); ctx.moveTo(32, 20);
            ctx.bezierCurveTo(32, 17, 30, 10, 20, 10); ctx.bezierCurveTo(10, 10, 10, 25, 10, 25);
            ctx.bezierCurveTo(10, 35, 20, 42, 32, 55); ctx.bezierCurveTo(44, 42, 54, 35, 54, 25);
            ctx.bezierCurveTo(54, 25, 54, 10, 44, 10); ctx.bezierCurveTo(36, 10, 32, 17, 32, 20); ctx.fill();
            const grad = ctx.createRadialGradient(32, 25, 2, 32, 25, 30); grad.addColorStop(0, "rgba(255,255,255,0.8)"); grad.addColorStop(1, "rgba(255,255,255,0)");
            ctx.fillStyle = grad; ctx.fill(); return new THREE.CanvasTexture(c);
        }

        function createGiftPatternTexture() {
            const c = document.createElement('canvas'); c.width=256; c.height=256; const ctx = c.getContext('2d');
            ctx.fillStyle = '#aa0000'; ctx.fillRect(0,0,256,256); ctx.fillStyle = 'rgba(255,255,255,0.8)';
            for(let i=0; i<30; i++) {
                const x = Math.random()*256, y=Math.random()*256, r=Math.random()*2+1; ctx.beginPath(); ctx.arc(x,y,r,0,7); ctx.fill();
                ctx.fillRect(x-4, y-0.5, 8, 1); ctx.fillRect(x-0.5, y-4, 1, 8);
            }
            const t = new THREE.CanvasTexture(c); t.wrapS = t.wrapT = THREE.RepeatWrapping; return t;
        }

        function createTextures() {
            const c = document.createElement('canvas'); c.width=128; c.height=128; const ctx = c.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,128,128); ctx.fillStyle = '#aa0000'; ctx.beginPath();
            for(let i=-128; i<256; i+=32) { ctx.moveTo(i, 0); ctx.lineTo(i+32, 128); ctx.lineTo(i+16, 128); ctx.lineTo(i-16, 0); }
            ctx.fill();
            caneTexture = new THREE.CanvasTexture(c); caneTexture.colorSpace = THREE.SRGBColorSpace;
            caneTexture.wrapS = caneTexture.wrapT = THREE.RepeatWrapping; caneTexture.repeat.set(3, 3);

            const sCvs = document.createElement('canvas'); sCvs.width=32; sCvs.height=32; const sCtx = sCvs.getContext('2d');
            const grad = sCtx.createRadialGradient(16,16,0, 16,16,16); grad.addColorStop(0, 'rgba(255,255,255,1)'); grad.addColorStop(1, 'rgba(255,255,255,0)');
            sCtx.fillStyle = grad; sCtx.fillRect(0,0,32,32); snowTexture = new THREE.CanvasTexture(sCvs);

            const pCvs = document.createElement('canvas'); pCvs.width=64; pCvs.height=64; const pCtx = pCvs.getContext('2d');
            const pGrad = pCtx.createRadialGradient(32,32,0, 32,32,32); pGrad.addColorStop(0, 'rgba(255,255,255,1)'); pGrad.addColorStop(1, 'rgba(0,0,0,0)');
            pCtx.fillStyle = pGrad; pCtx.fillRect(0,0,64,64); particleTexture = new THREE.CanvasTexture(pCvs);

            const gCvs = document.createElement('canvas'); gCvs.width=64; gCvs.height=64; const gCtx = gCvs.getContext('2d');
            const gGrad = gCtx.createRadialGradient(32,32,0, 32,32,32);
            gGrad.addColorStop(0, 'rgba(255, 200, 100, 1)');
            gGrad.addColorStop(0.5, 'rgba(255, 150, 50, 0.3)');
            gGrad.addColorStop(1, 'rgba(0,0,0,0)');
            gCtx.fillStyle = gGrad; gCtx.fillRect(0,0,64,64);
            glowTexture = new THREE.CanvasTexture(gCvs);

            heartTexture = createHeartTexture(); giftPatternTexture = createGiftPatternTexture();
        }

        function createMaterials() {
            matLib.gold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.15, envMapIntensity: 2.5, emissive: 0x664400, emissiveIntensity: 0.2 });
            matLib.green = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, metalness: 0.4, roughness: 0.3, emissive: 0x001100, emissiveIntensity: 0.1 });
            matLib.red = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.red, metalness: 0.6, roughness: 0.2, clearcoat: 1.0, emissive: 0x330000, emissiveIntensity: 0.4 });
            matLib.candy = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.3, metalness: 0.1, emissive: 0x222222 });
            matLib.starGold = new THREE.MeshStandardMaterial({ color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 2.0, metalness: 1.0, roughness: 0 });
            matLib.frameGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.2 });

            const frostTex = createFrostTexture();
            matLib.ice = new THREE.MeshPhysicalMaterial({
                color: CONFIG.colors.iceBlue, metalness: 0.1, roughness: 0.1, roughnessMap: frostTex,
                transmission: 0.9, thickness: 2.5, ior: 1.5, clearcoat: 1.0, clearcoatRoughnessMap: frostTex,
                emissive: 0x001133, emissiveIntensity: 0.2
            });
            matLib.snowBorder = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, side: THREE.BackSide });
            matLib.starSnow = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xaaddff, emissiveIntensity: 1.0, metalness: 0.2, roughness: 0.1 });
            matLib.snow = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.0, roughness: 0.9, emissive: 0xaaaaaa, emissiveIntensity: 0.3 });
            matLib.frameIce = matLib.ice;
            matLib.dust = new THREE.MeshBasicMaterial({ color: 0xffffee, blending: THREE.AdditiveBlending });
            matLib.snowFlake = new THREE.PointsMaterial({ color: 0xffffff, size: 0.6, map: snowTexture, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false });

            matLib.pink = new THREE.MeshStandardMaterial({ color: CONFIG.colors.pinkDeep, metalness: 0.6, roughness: 0.2, emissive: 0x442233, emissiveIntensity: 0.2 });
            matLib.pearl = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.pearl, metalness: 0.1, roughness: 0.1, clearcoat: 1.0, transmission: 0.2, opacity: 0.95, transparent: true, iridescence: 1.0 });
            matLib.starPink = new THREE.MeshStandardMaterial({ color: CONFIG.colors.pink, emissive: CONFIG.colors.pinkDeep, emissiveIntensity: 1.5, metalness: 0.6, roughness: 0.1 });
            matLib.framePink = new THREE.MeshStandardMaterial({ color: CONFIG.colors.pinkDeep, metalness: 0.8, roughness: 0.2 });
            matLib.heartParticle = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, map: heartTexture, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false });

            matLib.trunk = new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.9, metalness: 0.1 });
            const SNOW_BRIGHTNESS = 0.5;
            matLib.groundSnow = new THREE.MeshStandardMaterial({ color: new THREE.Color(SNOW_BRIGHTNESS, SNOW_BRIGHTNESS, SNOW_BRIGHTNESS), roughness: 1.0, metalness: 0.0, bumpMap: frostTex, bumpScale: 1.5 });
            matLib.giftRed = new THREE.MeshStandardMaterial({ map: giftPatternTexture, roughness: 0.4 });
            matLib.ribbonGreen = new THREE.MeshStandardMaterial({ color: 0x004400, roughness: 0.2, metalness: 0.4 });
            matLib.ribbonRed = new THREE.MeshStandardMaterial({ color: 0xaa0000, roughness: 0.2, metalness: 0.4 });
            matLib.stockingRed = new THREE.MeshStandardMaterial({ color: 0xaa0000, roughness: 0.9 });
            matLib.stockingWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
            matLib.wood = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.9 });
            matLib.velvetRed = new THREE.MeshStandardMaterial({ color: 0x880000, roughness: 0.8 });
            matLib.noseOrange = new THREE.MeshStandardMaterial({ color: CONFIG.colors.orange, roughness: 0.5 });
            matLib.eyeBlack = new THREE.MeshStandardMaterial({ color: CONFIG.colors.black, roughness: 0.2 });
            matLib.snowman = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9, metalness: 0.0, emissive: 0x000000 });
        }

        function createParticles() {
            const sphereGeo = new THREE.SphereGeometry(0.5, 16, 16), boxGeo = new THREE.BoxGeometry(0.45, 0.45, 0.45);
            const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(0,-0.5,0), new THREE.Vector3(0,0.3,0), new THREE.Vector3(0.1,0.5,0), new THREE.Vector3(0.3,0.4,0)]);
            const candyGeo = new THREE.TubeGeometry(curve, 8, 0.08, 6, false), dustGeo = new THREE.OctahedronGeometry(0.1, 0);
            const snowChunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.2, 7);
            const bowGeo = new THREE.TorusKnotGeometry(0.25, 0.08, 64, 8);

            for (let i = 0; i < CONFIG.particles.count; i++) {
                const rand = Math.random(); let mesh, type;
                if (rand < 0.25) { mesh = new THREE.Mesh(boxGeo, matLib.green); type = 'BOX'; }
                else if (rand < 0.50) { mesh = new THREE.Mesh(boxGeo, matLib.gold); type = 'GOLD_BOX'; }
                else if (rand < 0.70) { mesh = new THREE.Mesh(sphereGeo, matLib.gold); type = 'GOLD_SPHERE'; }
                else if (rand < 0.80) { mesh = new THREE.Mesh(sphereGeo, matLib.red); type = 'RED'; }
                else if (rand < 0.88) { mesh = new THREE.Mesh(candyGeo, matLib.candy); type = 'CANE'; }
                else if (rand < 0.94) { mesh = new THREE.Mesh(bowGeo, matLib.ribbonRed); type = 'ACCENT_BOW'; }
                else { mesh = new THREE.Mesh(snowChunkGeo, matLib.snow); type = 'SNOW_CHUNK'; }

                let s = 0.4 + Math.random() * 0.4;
                if (type === 'SNOW_CHUNK' || type === 'ACCENT_BOW') s *= 1.5;

                mesh.scale.set(s,s,s);
                mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
                mainGroup.add(mesh); particleSystem.push(new Particle(mesh, type, false));
            }
            for(let i=0; i<CONFIG.particles.dustCount; i++) {
                const mesh = new THREE.Mesh(dustGeo, matLib.dust); mesh.scale.setScalar(0.5 + Math.random());
                mainGroup.add(mesh); particleSystem.push(new Particle(mesh, 'DUST', true));
            }
            createToppers();
        }

        function createGalaxyBackground() {
            const geometry = new THREE.BufferGeometry(), count = 3000;
            const pos = new Float32Array(count * 3), sizes = new Float32Array(count), colors = new Float32Array(count * 3);
            const c1 = new THREE.Color(0x88aaff), c2 = new THREE.Color(0xffffee), c3 = new THREE.Color(0xffd700);
            for(let i=0; i<count; i++) {
                const r = 60 + Math.random()*250, theta = Math.random()*Math.PI*2, phi = Math.acos(2*Math.random()-1);
                pos[i*3] = r*Math.sin(phi)*Math.cos(theta); pos[i*3+1] = r*Math.sin(phi)*Math.sin(theta); pos[i*3+2] = r*Math.cos(phi);
                sizes[i] = Math.random()*2.0;
                let c = Math.random(), finalC = c<0.6?c2:(c<0.9?c1:c3);
                colors[i*3]=finalC.r; colors[i*3+1]=finalC.g; colors[i*3+2]=finalC.b;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            galaxySystem = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 1.0, transparent: true, opacity: 0.8, vertexColors: true, sizeAttenuation: true, blending: THREE.AdditiveBlending, depthWrite: false }));
            bgGroup.add(galaxySystem);
        }

        function createSnowBackground() {
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.particles.snowCount;
            const pos = new Float32Array(count * 3);
            const velocities = new Float32Array(count);
            for(let i=0; i<count; i++) {
                pos[i*3] = (Math.random() - 0.5) * 100; pos[i*3+1] = (Math.random() - 0.5) * 100; pos[i*3+2] = (Math.random() - 0.5) * 60; velocities[i] = 1.0 + Math.random();
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));
            snowSystem = new THREE.Points(geometry, matLib.snowFlake);
            snowSystem.visible = false;
            bgGroup.add(snowSystem);
        }

        function createHeartBackground() {
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.particles.heartCount;
            const pos = new Float32Array(count * 3);
            const velocities = new Float32Array(count);
            const offsets = new Float32Array(count);
            for(let i=0; i<count; i++) {
                pos[i*3] = (Math.random() - 0.5) * 100; pos[i*3+1] = (Math.random() - 0.5) * 100; pos[i*3+2] = (Math.random() - 0.5) * 60;
                velocities[i] = 0.5 + Math.random() * 0.8; offsets[i] = Math.random() * Math.PI * 2;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));
            geometry.setAttribute('offset', new THREE.BufferAttribute(offsets, 1));
            heartSystem = new THREE.Points(geometry, matLib.heartParticle);
            heartSystem.visible = false;
            bgGroup.add(heartSystem);
        }

        function createEnvironment() {
            const envGroup = new THREE.Group();
            STATE.environmentGroup = envGroup;
            mainGroup.add(envGroup);

            // 1. Ê†ëÂπ≤ (ÁßªÈô§)
            // const trunkGeo = new THREE.CylinderGeometry(0.8, 1.6, 12, 16); trunkGeo.translate(0, 6, 0);
            // const trunk = new THREE.Mesh(trunkGeo, matLib.trunk); trunk.position.y = -CONFIG.particles.treeHeight/2 - 2; envGroup.add(trunk);

            // 2. Èõ™Âú∞
            const groundGeo = new THREE.CircleGeometry(15, 64);
            const ground = new THREE.Mesh(groundGeo, matLib.groundSnow); ground.rotation.x = -Math.PI / 2; ground.position.y = -CONFIG.particles.treeHeight/2 - 2; ground.receiveShadow = true; envGroup.add(ground);

            // 3. ÁßØÈõ™Â†Ü
            for(let i=0; i<15; i++) {
                const moundSize = 2.5 + Math.random() * 2.5;
                const mound = new THREE.Mesh(new THREE.SphereGeometry(moundSize, 16, 8, 0, Math.PI*2, 0, Math.PI/2), matLib.groundSnow);
                mound.scale.y = 0.4; const angle = Math.random() * Math.PI * 2; const dist = 3 + Math.random() * 8;
                mound.position.set(Math.cos(angle)*dist, -CONFIG.particles.treeHeight/2 - 2.2, Math.sin(angle)*dist); envGroup.add(mound);
            }
            const bigPile = new THREE.Mesh(new THREE.SphereGeometry(6, 32, 16, 0, Math.PI*2, 0, Math.PI/2), matLib.groundSnow);
            bigPile.scale.set(1.5, 0.7, 1.2); bigPile.position.set(6, -CONFIG.particles.treeHeight/2 - 3, -6); envGroup.add(bigPile);

            // 4. Ë∂ÖÂ§ßÁ§ºÂìÅÁõí
            const giantBox = new THREE.Mesh(new THREE.BoxGeometry(7, 5.5, 7), matLib.giftRed);
            const gRibbon1 = new THREE.Mesh(new THREE.BoxGeometry(7.1, 5.5, 1.0), matLib.ribbonGreen); const gRibbon2 = new THREE.Mesh(new THREE.BoxGeometry(1.0, 5.5, 7.1), matLib.ribbonGreen);
            giantBox.add(gRibbon1); giantBox.add(gRibbon2);
            const lid = new THREE.Mesh(new THREE.BoxGeometry(7.4, 0.6, 7.4), matLib.giftRed); lid.position.y = 3.0; giantBox.add(lid);
            giantBox.position.set(-9, -CONFIG.particles.treeHeight/2 + 0.5, 6); giantBox.rotation.y = 0.6; envGroup.add(giantBox);

            // 5. Èõ™‰∫∫
            const createSnowman = (x, z, ry) => {
                const sGroup = new THREE.Group();
                const bot = new THREE.Mesh(new THREE.SphereGeometry(2.2, 16, 16), matLib.snowman); bot.position.y = 1.8;
                const mid = new THREE.Mesh(new THREE.SphereGeometry(1.6, 16, 16), matLib.snowman); mid.position.y = 4.5;
                const head = new THREE.Mesh(new THREE.SphereGeometry(1.1, 16, 16), matLib.snowman); head.position.y = 6.6;
                sGroup.add(bot); sGroup.add(mid); sGroup.add(head);
                const nose = new THREE.Mesh(new THREE.ConeGeometry(0.2, 1.2, 8), matLib.noseOrange); nose.rotation.x = Math.PI/2; nose.position.set(0, 6.6, 1.0); sGroup.add(nose);
                const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.15), matLib.eyeBlack); eye1.position.set(-0.4, 6.8, 0.9);
                const eye2 = eye1.clone(); eye2.position.set(0.4, 6.8, 0.9); sGroup.add(eye1); sGroup.add(eye2);
                const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 2.5);
                const arm1 = new THREE.Mesh(armGeo, matLib.trunk); arm1.rotation.z = Math.PI/3; arm1.position.set(-1.8, 4.8, 0);
                const arm2 = new THREE.Mesh(armGeo, matLib.trunk); arm2.rotation.z = -Math.PI/3; arm2.position.set(1.8, 4.8, 0);
                sGroup.add(arm1); sGroup.add(arm2);
                const hatBrim = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.1, 16), matLib.stockingRed); hatBrim.position.y = 7.5;
                const hatTop = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 1.2, 16), matLib.stockingRed); hatTop.position.y = 8.1;
                sGroup.add(hatBrim); sGroup.add(hatTop);
                sGroup.position.set(x, -CONFIG.particles.treeHeight/2 - 2, z); sGroup.rotation.y = ry; envGroup.add(sGroup);
            };
            createSnowman(7, 5, -0.8);

            // 6. Èõ™Ê©á & ÈïøÊ§Ö
            const createSleigh = (x, z, ry) => {
                const sGroup = new THREE.Group();
                const runnerGeo = new THREE.TorusGeometry(3, 0.1, 8, 24, Math.PI/1.5);
                const r1 = new THREE.Mesh(runnerGeo, matLib.gold); r1.rotation.x = Math.PI/2; r1.position.set(-1.2, 0.5, 0);
                const r2 = new THREE.Mesh(runnerGeo, matLib.gold); r2.rotation.x = Math.PI/2; r2.position.set(1.2, 0.5, 0);
                sGroup.add(r1); sGroup.add(r2);
                const seat = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.2, 3), matLib.wood); seat.position.y = 1.2; sGroup.add(seat);
                const back = new THREE.Mesh(new THREE.BoxGeometry(2.6, 1.5, 0.2), matLib.wood); back.position.set(0, 2.0, -1.4); sGroup.add(back);
                const cushion = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.15, 2.8), matLib.velvetRed); cushion.position.y = 1.35; sGroup.add(cushion);
                sGroup.position.set(x, -CONFIG.particles.treeHeight/2 - 2, z); sGroup.rotation.y = ry; sGroup.scale.setScalar(1.5); envGroup.add(sGroup);
            };
            const createBench = (x, z, ry) => {
                const bGroup = new THREE.Group();
                const legGeo = new THREE.BoxGeometry(0.2, 1.5, 0.2);
                const l1 = new THREE.Mesh(legGeo, matLib.wood); l1.position.set(-1.2, 0.75, 0.5);
                const l2 = new THREE.Mesh(legGeo, matLib.wood); l2.position.set(1.2, 0.75, 0.5);
                const l3 = new THREE.Mesh(legGeo, matLib.wood); l3.position.set(-1.2, 0.75, -0.5);
                const l4 = new THREE.Mesh(legGeo, matLib.wood); l4.position.set(1.2, 0.75, -0.5);
                bGroup.add(l1); bGroup.add(l2); bGroup.add(l3); bGroup.add(l4);
                const seat = new THREE.Mesh(new THREE.BoxGeometry(3, 0.15, 1.4), matLib.wood); seat.position.y = 1.6; bGroup.add(seat);
                const snowOnBench = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.05, 1.2), matLib.snow); snowOnBench.position.y = 1.7; bGroup.add(snowOnBench);
                bGroup.position.set(x, -CONFIG.particles.treeHeight/2 - 2, z); bGroup.rotation.y = ry; bGroup.scale.setScalar(1.4); envGroup.add(bGroup);
            };
            createSleigh(8, -2, -0.6); createBench(-5, 6, 0.8);

            // Ë£ÖÈ•∞ÂìÅ
            const createGift = (x, z, ry) => {
                const boxSize = 2.2 + Math.random();
                const box = new THREE.Mesh(new THREE.BoxGeometry(boxSize, boxSize, boxSize), matLib.giftRed);
                const ribbon1 = new THREE.Mesh(new THREE.BoxGeometry(boxSize*1.02, boxSize*0.1, boxSize*1.02), matLib.ribbonGreen);
                const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(boxSize*0.1, boxSize*1.02, boxSize*1.02), matLib.ribbonGreen);
                box.add(ribbon1); box.add(ribbon2);
                box.position.set(x, -CONFIG.particles.treeHeight/2 - 2 + boxSize/2, z); box.rotation.y = ry; envGroup.add(box);
            };
            const createStocking = (x, z, ry) => {
                const g = new THREE.Group();
                const foot = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 1, 4, 8), matLib.stockingRed); foot.rotation.z = Math.PI/2; foot.position.x = 0.3;
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 1.5, 8), matLib.stockingRed); leg.position.y = 0.5; leg.position.x = -0.3;
                const top = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.45, 0.4, 8), matLib.stockingWhite); top.position.y = 1.2; top.position.x = -0.3;
                g.add(foot); g.add(leg); g.add(top);
                g.position.set(x, -CONFIG.particles.treeHeight/2 - 2 + 0.5, z); g.rotation.y = ry; g.scale.setScalar(2.0); envGroup.add(g);
            };
            for(let i=0; i<5; i++) { const angle = Math.random() * Math.PI * 2; const r = 5 + Math.random() * 6; createGift(Math.cos(angle)*r, Math.sin(angle)*r, Math.random()*3); }
            for(let i=0; i<3; i++) { const angle = Math.random() * Math.PI * 2; const r = 4 + Math.random() * 4; createStocking(Math.cos(angle)*r, Math.sin(angle)*r, angle + Math.PI/2); }
        }

        class Particle {
            constructor(mesh, type, isDust = false) {
                this.mesh = mesh; this.type = type; this.isDust = isDust;
                this.posTree = new THREE.Vector3(); this.posScatter = new THREE.Vector3(); this.posText = new THREE.Vector3();
                this.baseScale = mesh.scale.x; this.offset = Math.random() * 100; this.speed = 0.5 + Math.random();
                if (mesh.material && mesh.material.emissive) { this.baseEmissive = mesh.material.emissive.clone(); this.hasEmissive = true; }
                this.calculatePositions();
            }

            calculatePositions() {
                const h = CONFIG.particles.treeHeight; let t = Math.random();
                if (this.type !== 'SNOW_CHUNK' && Math.random() > 0.7 && !this.isDust && this.type !== 'PHOTO') {
                    const y = (t * h) - h/2, angle = t * Math.PI * 12, rBase = CONFIG.particles.treeRadius * (1.0 - t);
                    this.posTree.set(Math.cos(angle) * rBase, y, Math.sin(angle) * rBase);
                } else {
                    t = Math.pow(t, 0.8); const y = (t * h) - h/2, angle = Math.random() * Math.PI * 2, r = Math.max(0.5, CONFIG.particles.treeRadius * (1.0 - t)) * Math.sqrt(Math.random());
                    this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
                }
                if (this.type === 'SNOW_CHUNK') { this.posTree.y += 0.5; this.posTree.multiplyScalar(1.05); }
                // ‰øÆÊîπÂêéÔºöÂ¢ûÂ§ß‰∫ÜÂü∫Á°ÄËåÉÂõ¥ÂíåÈöèÊú∫ËåÉÂõ¥
                const rScatter = this.isDust ? (30 + Math.random()*50) : (20 + Math.random()*40);
                const theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(rScatter * Math.sin(phi) * Math.cos(theta), rScatter * Math.sin(phi) * Math.sin(theta), rScatter * Math.cos(phi));

                if (textPoints.length > 0) {
                    const p = textPoints[Math.floor(Math.random() * textPoints.length)];
                    this.posText.set(p.x + (Math.random()-0.5)*0.2, p.y + (Math.random()-0.5)*0.2, p.z);
                } else { this.posText.copy(this.posScatter); }
            }

            update(dt, time, mode, focusTargetMesh, invMatrix) {
                let target, s = this.baseScale, lerpSpeed = 3.0;

                if (mode === 'SCATTER') { target = _targetVec.copy(this.posScatter).multiplyScalar(STATE.scatterScale); }
                else if (mode === 'LETTER') target = this.posScatter;
                else if (mode === 'TEXT') {
                    target = this.posText;
                    if(this.type === 'GOLD_SPHERE' || this.type === 'RED' || this.type === 'BOX') {
                        this.mesh.material.emissiveIntensity = 1.0 + Math.sin(time * 5 + this.offset) * 0.5;
                    }
                }
                else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh && invMatrix) {
                        target = _targetVec.set(0, 0, CONFIG.camera.z - 15).applyMatrix4(invMatrix); s = this.baseScale * 5.0; lerpSpeed = 6.0;
                        this.mesh.lookAt(camera.position);
                    } else { target = this.posScatter; s = 0.01; }
                } else { target = this.posTree; }

                _tempVec.copy(target);
                if(mode === 'TREE') { _tempVec.y += Math.sin(time * this.speed + this.offset) * 0.15; _tempVec.x += Math.cos(time * 0.5 * this.speed + this.offset) * 0.1; }
                this.mesh.position.lerp(_tempVec, lerpSpeed * dt);

                if (this.hasEmissive && mode === 'TREE' && !this.isDust) {
                    const blink = Math.sin(time * 2 + this.offset);
                    this.mesh.material.emissiveIntensity = blink > 0.5 ? (1.0 + (blink - 0.5) * 2.5) : 0.4;
                }

                if (mode !== 'FOCUS') {
                    if (this.isDust) s = this.baseScale * (0.5 + 0.5 * Math.sin(time * 3 + this.offset));
                    else if ((mode === 'SCATTER' || mode === 'LETTER') && this.type === 'PHOTO') s = this.baseScale * 2.5;
                }
                this.mesh.scale.lerp(_tempVec.set(s,s,s), 5*dt);
            }
        }

        class FireworkParticle {
            constructor() {
                const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(3), 3));
                const colors = [CONFIG.colors.fireworkSilver, CONFIG.colors.fireworkGold, CONFIG.colors.fireworkGreen];
                this.mesh = new THREE.Points(geometry, new THREE.PointsMaterial({
                    color: new THREE.Color(colors[Math.floor(Math.random() * colors.length)]),
                    size: 1.5, map: particleTexture, transparent: true, opacity: 1, blending: THREE.AdditiveBlending, depthWrite: false
                }));
                this.velocity = new THREE.Vector3(); this.reset(); fireworkGroup.add(this.mesh);
            }
            reset() { this.life = 0; this.maxLife = 1.5 + Math.random(); this.active = false; this.mesh.visible = false; }
            launch(origin) {
                this.active = true; this.mesh.visible = true; this.mesh.position.copy(origin);
                const speed = 0.5 + Math.random() * 1.5; const theta = Math.random()*Math.PI*2; const phi = Math.random()*Math.PI;
                this.velocity.set(Math.sin(phi)*Math.cos(theta)*speed, Math.sin(phi)*Math.sin(theta)*speed, Math.cos(phi)*speed);
            }
            update(dt) {
                if (!this.active) return;
                this.life += dt; if (this.life > this.maxLife) { this.reset(); return; }
                this.velocity.y -= 1.0 * dt; this.velocity.multiplyScalar(0.98); this.mesh.position.add(this.velocity);
                const progress = this.life / this.maxLife; this.mesh.material.opacity = 1 - Math.pow(progress, 2);
                this.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        function launchFireworks() {
            if(Math.random() > 0.1) return;
            const origin = new THREE.Vector3((Math.random()-0.5)*50, (Math.random()*20)+5, (Math.random()-0.5)*30);
            let count = 0; const batchSize = 30 + Math.floor(Math.random()*20);
            for(let f of fireworks) { if(!f.active) { f.launch(origin); count++; if(count >= batchSize) break; } }
        }

        // üåü ÁîüÊàêÂÆû‰ΩìËû∫Êóã‰∏ùÂ∏¶ÁöÑÂáΩÊï∞ (Ê†∏ÂøÉ‰øÆÊîπ)
        function createRibbon(colorHex, emissiveHex) {
            const ribbonPoints = [];
            const ribbonH = 32; // È´òÂ∫¶Á®çÈ´ò‰∫éÊ†ë
            const turns = 6;    // Áº†ÁªïÂúàÊï∞
            
            // ÁîüÊàêËû∫ÊóãË∑ØÂæÑÁÇπ
            for(let i=0; i<150; i++) {
                const t = i/150;
                const angle = t * Math.PI * 2 * turns; 
                // ÂçäÂæÑ‰ªéÂ∫ïÈÉ®12ÈÄêÊ∏êÁº©Â∞èÂà∞È°∂ÈÉ®0.5ÔºåÂΩ¢ÊàêÂúÜÈî•Ëû∫Êóã
                const r = (1-t) * 12 + 0.5; 
                const y = t * ribbonH - ribbonH/2 - 2;
                ribbonPoints.push(new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r));
            }
            
            // ÂàõÂª∫ÁÆ°ÈÅìÂá†‰Ωï‰Ωì
            const ribbonGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(ribbonPoints), 100, 0.15, 8, false);
            
            // ÂàõÂª∫ÂèëÂÖâÊùêË¥®
            const ribbonMat = new THREE.MeshStandardMaterial({
                color: colorHex,
                emissive: emissiveHex,
                emissiveIntensity: 3.0, // Âº∫ÁÉàÁöÑÂèëÂÖâÊïàÊûú
                transparent: true,
                opacity: 0.9,
                roughness: 0.2,
                metalness: 0.8
            });
            
            return new THREE.Mesh(ribbonGeo, ribbonMat);
        }

        function createToppers() {
            const extrudeSettings = { depth: 2, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 0.2, bevelThickness: 0.2 };
            const pos = new THREE.Vector3(0, CONFIG.particles.treeHeight/2 + 1.2, 0);

            // --- 1. ÈáëËâ≤‰∏ªÈ¢ò ---
            // ÊòüÊòü
            const starShape = new THREE.Shape(); const pts = []; const numPoints = 5;
            for(let i=0; i<numPoints*2; i++) { const l = i%2==0 ? 10 : 4; const a = i/numPoints * Math.PI; pts.push(new THREE.Vector2(Math.cos(a)*l, Math.sin(a)*l)); }
            starShape.setFromPoints(pts);
            const starGeo = new THREE.ExtrudeGeometry(starShape, extrudeSettings); starGeo.center();
            const starMesh = new THREE.Mesh(starGeo, matLib.starGold); starMesh.scale.setScalar(0.15); starMesh.position.copy(pos);
            starGroup.add(starMesh); STATE.toppers.star = starMesh;

            // ËÉåÊôØÂÖâÊôï
            const halo = new THREE.Mesh(new THREE.PlaneGeometry(8, 8), new THREE.MeshBasicMaterial({
                map: glowTexture, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.5, color: 0xffaa00
            }));
            halo.position.copy(pos); starGroup.add(halo); STATE.starHaloMesh = halo;

            // üåü ÈáëËâ≤ÂÆû‰ΩìÊµÅÂÖâ‰∏ùÂ∏¶ (ÂèÇËÄÉ 1.html ÊïàÊûú)
            const goldRibbon = createRibbon(CONFIG.colors.gold, CONFIG.colors.gold);
            mainGroup.add(goldRibbon); STATE.toppers.goldRibbon = goldRibbon;


            // --- 2. ÂÜ∞Èõ™‰∏ªÈ¢ò ---
            // ÂÜ∞Èõ™ÊòüÊòü
            const snowShape = new THREE.Shape(); const w=1.5, h=10; snowShape.moveTo(-w, -h); snowShape.lineTo(w, -h); snowShape.lineTo(w, h); snowShape.lineTo(-w, h);
            const snowGeo = new THREE.ExtrudeGeometry(snowShape, extrudeSettings); snowGeo.center();
            const snowMesh = new THREE.Mesh(snowGeo, matLib.starSnow); const s2 = snowMesh.clone(); s2.rotation.z = Math.PI/3; snowMesh.add(s2); const s3 = snowMesh.clone(); s3.rotation.z = -Math.PI/3; snowMesh.add(s3);
            snowMesh.scale.setScalar(0.16); snowMesh.position.copy(pos); snowMesh.visible = false; starGroup.add(snowMesh); STATE.toppers.snow = snowMesh;

            // üåü ÂÜ∞Èõ™ÊµÅÂÖâ‰∏ùÂ∏¶
            const snowRibbon = createRibbon(0xffffff, 0xaaddff); // ÁôΩÂ∫ïËìùÂÖâ
            snowRibbon.visible = false; mainGroup.add(snowRibbon); STATE.toppers.snowRibbon = snowRibbon;

            // ‰øùÁïôÔºöÊ†ëÈ°∂Èõ™Ëä±Áº†Áªï (snowOrbit)
            const snowOrbitGroup = new THREE.Group(); snowOrbitGroup.position.copy(pos);
            const snowSpriteMat = new THREE.SpriteMaterial({ map: snowTexture, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
            for(let i=0; i<12; i++) {
                const sprite = new THREE.Sprite(snowSpriteMat); sprite.scale.setScalar(0.8 + Math.random()*0.5);
                const angle = (i/12)*Math.PI*2; const radius = 1.8 + Math.random()*0.5;
                sprite.position.set(Math.cos(angle)*radius, (Math.random()-0.5)*0.5, Math.sin(angle)*radius);
                sprite.userData = { rotSpeed: (Math.random()-0.5)*2 }; snowOrbitGroup.add(sprite);
            }
            snowOrbitGroup.visible = false; starGroup.add(snowOrbitGroup); STATE.toppers.snowOrbit = snowOrbitGroup;


            // --- 3. Á≤âËâ≤‰∏ªÈ¢ò ---
            // Á≤âËâ≤ÊòüÊòü
            const heartShape = new THREE.Shape(); const x = 0, y = 0; heartShape.moveTo( x + 5, y + 5 ); heartShape.bezierCurveTo( x + 5, y + 5, x + 4, y, x, y );
            heartShape.bezierCurveTo( x - 6, y, x - 6, y + 7,x - 6, y + 7 ); heartShape.bezierCurveTo( x - 6, y + 11, x - 3, y + 15.4, x + 5, y + 19 );
            heartShape.bezierCurveTo( x + 12, y + 15.4, x + 16, y + 11, x + 16, y + 7 ); heartShape.bezierCurveTo( x + 16, y + 7, x + 16, y, x + 10, y ); heartShape.bezierCurveTo( x + 7, y, x + 5, y + 5, x + 5, y + 5 );
            const heartGeo = new THREE.ExtrudeGeometry(heartShape, extrudeSettings); heartGeo.center();
            const heartMesh = new THREE.Mesh(heartGeo, matLib.starPink); heartMesh.rotation.set(0, 0, Math.PI); heartMesh.scale.setScalar(0.14); heartMesh.position.copy(pos); heartMesh.visible = false;
            starGroup.add(heartMesh); STATE.toppers.heart = heartMesh;

            // üåü Á≤âËâ≤ÊµÅÂÖâ‰∏ùÂ∏¶
            const heartRibbon = createRibbon(CONFIG.colors.pink, CONFIG.colors.pinkDeep);
            heartRibbon.visible = false; mainGroup.add(heartRibbon); STATE.toppers.heartRibbon = heartRibbon;

            // ‰øùÁïôÔºöÊ†ëÈ°∂Áà±ÂøÉÁº†Áªï (heartOrbit)
            const heartOrbitGroup = new THREE.Group(); heartOrbitGroup.position.copy(pos);
            const heartPointMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2.0, map: heartTexture, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false });
            const heartOrbitGeo = new THREE.BufferGeometry(); const heartPos = [];
            for(let i=0; i<16; i++) { const angle=(i/16)*Math.PI*2; const radius=2.0+Math.random()*0.6; const yOffset=(i/16-0.5)*1.5; heartPos.push(Math.cos(angle)*radius, yOffset, Math.sin(angle)*radius); }
            heartOrbitGeo.setAttribute('position', new THREE.Float32BufferAttribute(heartPos, 3));
            const heartOrbitPoints = new THREE.Points(heartOrbitGeo, heartPointMat);
            heartOrbitGroup.add(heartOrbitPoints); heartOrbitGroup.visible = false; starGroup.add(heartOrbitGroup); STATE.toppers.heartOrbit = heartOrbitGroup;
        }

        function switchTheme(themeIndex) {
            STATE.currentThemeIndex = themeIndex;
            renderer.toneMappingExposure = (themeIndex === 1) ? 0.6 : 1.0;
            if (galaxySystem) galaxySystem.visible = (themeIndex === 0);
            if (snowSystem) snowSystem.visible = (themeIndex === 1);
            if (heartSystem) heartSystem.visible = (themeIndex === 2);

            particleSystem.forEach(p => {
                if (p.isDust) return;
                if (p.type === 'PHOTO') {
                    const group = p.mesh; let frameMat;
                    if (themeIndex === 0) frameMat = matLib.frameGold; else if (themeIndex === 1) frameMat = matLib.ice; else frameMat = matLib.framePink;
                    if (group.children[0]) group.children[0].material = frameMat; if (group.children[2]) group.children[2].visible = (themeIndex !== 0);
                    return;
                }
                let newMat;
                if (p.type === 'SNOW_CHUNK') { newMat = matLib.snow; }
                else if (p.type === 'ACCENT_BOW') {
                    if (themeIndex === 0) newMat = matLib.ribbonRed;
                    else if (themeIndex === 1) newMat = (Math.random()>0.5) ? matLib.ribbonRed : matLib.ribbonGreen;
                    else newMat = matLib.ribbonGreen;
                } else if (themeIndex === 0) {
                    if(p.type.includes('GOLD')) newMat = matLib.gold; else if(p.type === 'BOX') newMat = matLib.green; else if(p.type === 'RED') newMat = matLib.red; else if(p.type === 'CANE') newMat = matLib.candy;
                } else if (themeIndex === 1) {
                    if(p.type.includes('GOLD') || p.type === 'BOX') newMat = matLib.ice; else if(p.type === 'RED') newMat = matLib.snow; else if(p.type === 'CANE') newMat = matLib.ice;
                } else {
                    if(p.type === 'BOX') newMat = matLib.pink; else if(p.type.includes('GOLD')) newMat = matLib.pink; else if(p.type === 'RED') newMat = matLib.pearl; else if(p.type === 'CANE') newMat = matLib.pink;
                }
                if (newMat) p.mesh.material = newMat;
            });

            // üåü ÂàáÊç¢‰∏ªÈ¢òÊó∂ÔºåÊéßÂà∂‰∏çÂêåÁªÑ‰ª∂ÁöÑÂèØËßÅÊÄß
            if (STATE.toppers.star) STATE.toppers.star.visible = (themeIndex === 0);
            if (STATE.toppers.goldRibbon) STATE.toppers.goldRibbon.visible = (themeIndex === 0); // ÈáëËâ≤Â§ß‰∏ùÂ∏¶

            if (STATE.toppers.snow) STATE.toppers.snow.visible = (themeIndex === 1);
            if (STATE.toppers.snowOrbit) STATE.toppers.snowOrbit.visible = (themeIndex === 1); // Ê†ëÈ°∂Èõ™Ëä±Áº†Áªï
            if (STATE.toppers.snowRibbon) STATE.toppers.snowRibbon.visible = (themeIndex === 1); // Ê†ëË∫´ÂÜ∞Èõ™Â§ß‰∏ùÂ∏¶

            if (STATE.toppers.heart) STATE.toppers.heart.visible = (themeIndex === 2);
            if (STATE.toppers.heartOrbit) STATE.toppers.heartOrbit.visible = (themeIndex === 2); // Ê†ëÈ°∂Áà±ÂøÉÁº†Áªï
            if (STATE.toppers.heartRibbon) STATE.toppers.heartRibbon.visible = (themeIndex === 2); // Ê†ëË∫´Á≤âËâ≤Â§ß‰∏ùÂ∏¶

            if (STATE.starHaloMesh) {
                let c; if (themeIndex === 0) c = 0xffaa00; else if (themeIndex === 1) c = CONFIG.colors.iceBlue; else c = CONFIG.colors.pinkDeep;
                STATE.starHaloMesh.material.color.setHex(c);
            }
        }

        // üåü ‰øÆÂ§çÔºöÁÖßÁâáÂè™Ê∑ªÂä†Âà∞Âú∫ÊôØÔºå‰∏çËá™Âä®ËÅöÁÑ¶ÊîæÂ§ß
        function addPhotoToScene(texture) {
            if (!texture.image) return;
            const aspect = texture.image.width / texture.image.height;
            let photoW = (aspect >= 1) ? 1.2 : 1.2 * aspect;
            let photoH = (aspect >= 1) ? 1.2 / aspect : 1.2;

            const group = new THREE.Group();

            // ÊùêË¥®ÈÄÇÈÖç
            const frameMat = (STATE.currentThemeIndex === 0) ? (matLib.frameGold || new THREE.MeshStandardMaterial({color: 0xffd700})) :
                             (STATE.currentThemeIndex === 1) ? (matLib.ice || new THREE.MeshStandardMaterial({color: 0xaaddff})) :
                             (matLib.framePink || new THREE.MeshStandardMaterial({color: 0xffc0cb}));

            const frame = new THREE.Mesh(new THREE.BoxGeometry(photoW + 0.15, photoH + 0.15, 0.1), frameMat);
            group.add(frame);

            const photo = new THREE.Mesh(new THREE.PlaneGeometry(photoW, photoH), new THREE.MeshBasicMaterial({ map: texture }));
            photo.position.z = 0.06;
            group.add(photo);

            const borderGeo = new THREE.BoxGeometry(photoW + 0.25, photoH + 0.25, 0.08);
            const border = new THREE.Mesh(borderGeo, matLib.snowBorder || new THREE.MeshBasicMaterial({color:0xffffff}));
            border.position.z = -0.02;
            border.visible = (STATE.currentThemeIndex !== 0);
            group.add(border);

            photoMeshGroup.add(group);

            // üåü Ê†∏ÂøÉ‰øÆÊîπÔºöÂè™Ê∑ªÂä†Á≤íÂ≠êÔºå‰∏çÂàáÊç¢Ê®°ÂºèÔºå‰πü‰∏çÈîÅÂÆöÁõÆÊ†á
            particleSystem.push(new Particle(group, 'PHOTO', false));

            // Ê≥®ÈáäÊéâËá™Âä®ÊîæÂ§ß‰ª£Á†Å
            // STATE.mode = 'FOCUS';
            // STATE.focusTarget = group;
        }

        // üåü Ë°•ÂÖ®ÔºöhandleImageUpload
        function handleImageUpload(e) {
            if(!e.target.files.length) return;
            Array.from(e.target.files).forEach(f => {
                const reader = new FileReader();
                reader.onload = (ev) => new THREE.TextureLoader().load(ev.target.result, t => {
                    t.colorSpace = THREE.SRGBColorSpace;
                    addPhotoToScene(t); // Ë∞ÉÁî®‰∏ä‰∏ÄÊ≠•‰øÆÂ§çÁöÑÁÖßÁâáÊ∑ªÂä†ÂáΩÊï∞
                });
                reader.readAsDataURL(f);
            });
        }

        function setupLetterSystem() {
            const modal = document.getElementById('letter-editor-modal'), txt = document.getElementById('letter-text-input');
            document.getElementById('btn-write-letter').onclick = (e) => { e.stopPropagation(); modal.style.display = 'flex'; txt.value = STATE.letterContent; };
            document.getElementById('btn-cancel-letter').onclick = (e) => { e.stopPropagation(); modal.style.display = 'none'; };
            document.getElementById('btn-save-letter').onclick = (e) => { e.stopPropagation(); if(txt.value.trim()) STATE.letterContent = txt.value.trim(); modal.style.display = 'none'; };
            document.getElementById('btn-close-letter-mode').onclick = (e) => { e.stopPropagation(); exitLetterMode(); };
        }

        function enterLetterMode() {
            if (STATE.mode === 'LETTER') return;
            STATE.mode = 'LETTER';
            const overlay = document.getElementById('letter-overlay'), paper = document.querySelector('.letter-paper'), display = document.getElementById('letter-content-display');
            overlay.style.display = 'flex';
            requestAnimationFrame(() => { overlay.style.opacity = 1; paper.style.transform = 'translateY(0)'; });

            display.textContent = '';
            display.classList.add('cursor');
            let i = 0;
            const typeWriter = () => {
                if (STATE.mode !== 'LETTER') return;
                if (i < STATE.letterContent.length) {
                    display.textContent += STATE.letterContent.charAt(i++);
                    display.scrollTop = display.scrollHeight;
                    STATE.letterTyper = setTimeout(typeWriter, 100);
                } else {
                    display.classList.remove('cursor');
                }
            };
            STATE.letterStartTimer = setTimeout(typeWriter, 1500);
        }

        function exitLetterMode() {
            STATE.mode = 'TREE'; clearTimeout(STATE.letterTyper); clearTimeout(STATE.letterStartTimer);
            const overlay = document.getElementById('letter-overlay'), paper = document.querySelector('.letter-paper');
            overlay.style.opacity = 0; paper.style.transform = 'translateY(20px)';
            setTimeout(() => { overlay.style.display = 'none'; }, 500);
            STATE.spinVel.set(0,0);
        }

        function exportWholePage() {
            const photos = particleSystem.filter(p => p.type === 'PHOTO').map(p => {
                try { return p.mesh.children[1].material.map.image.src; } catch(e) { return null; }
            }).filter(src => src !== null);

            const exportData = {
                music: STATE.musicData,
                letter: STATE.letterContent,
                photos: photos,
                theme: STATE.currentThemeIndex,
                title: document.getElementById('main-title').innerText,
                isGestureSwitchEnabled: STATE.isGestureSwitchEnabled
            };

            let fullHTML = document.documentElement.outerHTML;
            fullHTML = fullHTML.replace(/<div id="canvas-container">[\s\S]*?<\/div>/, '<div id="canvas-container"></div>');
            fullHTML = fullHTML.replace(/<div id="loader"[^>]*>/, '<div id="loader">');

            const dataString = JSON.stringify(exportData);
            const injectionPoint = 'const PRELOADED_DATA = null;';
            const injectedCode = `const PRELOADED_DATA = ${dataString};`;
            if (fullHTML.includes(injectionPoint)) {
                fullHTML = fullHTML.replace(injectionPoint, injectedCode);
            }

            // ÂØºÂá∫ÂêéÁöÑÊ†∑Âºè‰ºòÂåñÔºö‰øùÁïôÊí≠ÊîæÂíåÈöêËóèÁõëÊéßÊåâÈíÆ
            const hideControlsStyle = `
<style>
    /* ÈöêËóèÁºñËæëÁ±ªÊåâÈíÆ */
    #btn-bg-music,
    #btn-add-photo,
    #btn-write-letter,
    #btn-set-title,
    #btn-import,
    #btn-export {
        display: none !important; 
    }

    /* Âº∫Âà∂ÊòæÁ§∫ÂÆπÂô® */
    #col-media, #col-system { 
        display: flex !important; 
    }

    /* Âº∫Âà∂ÊòæÁ§∫ÊéßÂà∂Á±ªÊåâÈíÆ */
    #btn-toggle-music,
    #btn-toggle-cam,
    #btn-fullscreen,
    #btn-switch-theme,
    #btn-help,
    #btn-share-native { 
        display: block !important; 
    }
</style>
`;
            fullHTML = fullHTML.replace('</head>', hideControlsStyle + '</head>');

            const blob = new Blob([fullHTML], {type: "text/html"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = "LuxuryTree_Share.html";
            a.click();
            URL.revokeObjectURL(url);
        }

        // üåü Ê†∏ÂøÉ‰øÆÂ§çÔºöÂØºÂÖ•Êï∞ÊçÆ + ÊâãÊú∫Ëá™Âä®Êí≠ÊîæÂ§ÑÁêÜ
        function importSceneData(jsonData, autoPlay = false) {
            try {
                const data = JSON.parse(jsonData);
                const loader = document.getElementById('loader');
                const startPrompt = document.getElementById('start-prompt');

                if (data.title) document.getElementById('main-title').innerText = data.title;
                if (data.letter) STATE.letterContent = data.letter;
                if (data.theme !== undefined) switchTheme(data.theme);

                if (data.isGestureSwitchEnabled !== undefined) {
                    STATE.isGestureSwitchEnabled = data.isGestureSwitchEnabled;
                    const btn = document.getElementById('btn-switch-theme');
                    if(btn) {
                        btn.textContent = STATE.isGestureSwitchEnabled ? "ÊâãÂäøÂàáÊç¢: ÂºÄ" : "ÊâãÂäøÂàáÊç¢: ÂÖ≥";
                        if(!STATE.isGestureSwitchEnabled) btn.classList.add('disabled');
                    }
                }

                // ÂáÜÂ§áÈü≥‰πê
                let audioReady = false;
                const audioEl = document.getElementById('bg-music');
                const musicBtn = document.getElementById('btn-toggle-music');
                if (data.music) {
                    STATE.musicData = data.music;
                    audioEl.src = data.music;
                    audioEl.load();
                    audioReady = true;
                }

                // ÊÅ¢Â§çÁÖßÁâá
                const photosToRemove = particleSystem.filter(p => p.type === 'PHOTO');
                photosToRemove.forEach(p => {
                    photoMeshGroup.remove(p.mesh);
                    p.mesh.traverse(c => { if(c.geometry) c.geometry.dispose(); });
                });
                particleSystem = particleSystem.filter(p => p.type !== 'PHOTO');

                if (data.photos && Array.isArray(data.photos)) {
                    const loaderTex = new THREE.TextureLoader();
                    data.photos.forEach(src => {
                        loaderTex.load(src, t => {
                            t.colorSpace = THREE.SRGBColorSpace;
                            addPhotoToScene(t); // ‰ΩøÁî®‰øÆÂ§çÂêéÁöÑÈùûËá™Âä®ÊîæÂ§ßÂáΩÊï∞
                        });
                    });
                }

                // üåü Ëá™Âä®Êí≠ÊîæÊ†∏ÂøÉÈÄªËæë
                if (autoPlay) {
                    console.log("Waiting for user interaction to start...");

                    if(loader) {
                        loader.style.opacity = 1;
                        loader.style.display = 'flex';
                        loader.style.zIndex = 9999;
                    }
                    if(startPrompt) startPrompt.style.display = 'block';

                    // ÁÇπÂáªÂ±èÂπïÊó∂Ëß¶ÂèëÊí≠Êîæ
                    const startExperience = () => {
                        if(audioReady) {
                            audioEl.play().then(() => {
                                if(musicBtn) musicBtn.textContent = "ÊöÇÂÅúÈü≥‰πê";
                            }).catch(e => {
                                console.warn("Audio autoplay blocked, retrying...", e);
                                audioEl.play();
                            });
                        }

                        try { if(document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(()=>{}); } catch(e){}

                        if(loader) {
                            loader.style.opacity = 0;
                            setTimeout(() => loader.style.display = 'none', 1000);
                        }

                        document.removeEventListener('click', startExperience);
                        document.removeEventListener('touchstart', startExperience);
                    };

                    document.addEventListener('click', startExperience);
                    document.addEventListener('touchstart', startExperience);
                }

            } catch (e) {
                console.error("Import failed:", e);
                if(document.getElementById('loader')) document.getElementById('loader').style.display = 'none';
            }
        }

        function setupEvents() {
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });
            const fileInput = document.getElementById('file-input');
            document.getElementById('btn-add-photo').onclick = (e) => { e.stopPropagation(); fileInput.click(); };
            fileInput.onchange = handleImageUpload;
            const musicInput = document.getElementById('music-input'), audioEl = document.getElementById('bg-music');
            document.getElementById('btn-bg-music').onclick = (e) => { e.stopPropagation(); musicInput.click(); };
            musicInput.onchange = (e) => {
                if(e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(evt) { STATE.musicData = evt.target.result; audioEl.src = evt.target.result; audioEl.currentTime = 0; audioEl.play().catch(console.warn); };
                    reader.readAsDataURL(e.target.files[0]);
                }
            };

            const btnToggleMusic = document.getElementById('btn-toggle-music');
            btnToggleMusic.onclick = (e) => {
                e.stopPropagation();
                if (audioEl.paused) {
                    audioEl.play().then(() => { btnToggleMusic.textContent = "ÊöÇÂÅúÈü≥‰πê"; }).catch(e=>alert("Êí≠ÊîæÂ§±Ë¥•ÔºåËØ∑ÂÖà‰∏ä‰º†Èü≥‰πê"));
                } else {
                    audioEl.pause();
                    btnToggleMusic.textContent = "Êí≠ÊîæÈü≥‰πê";
                }
            };
            audioEl.addEventListener('play', () => btnToggleMusic.textContent = "ÊöÇÂÅúÈü≥‰πê");
            audioEl.addEventListener('pause', () => btnToggleMusic.textContent = "Êí≠ÊîæÈü≥‰πê");

            document.getElementById('btn-set-title').onclick = (e) => {
                e.stopPropagation();
                const newMain = prompt("ËØ∑ËæìÂÖ•‰∏ªÊ†áÈ¢ò:", document.getElementById('main-title').innerText);
                if (newMain !== null) document.getElementById('main-title').innerText = newMain;
                const newSub = prompt("ËØ∑ËæìÂÖ•ÂâØÊ†áÈ¢ò:", document.getElementById('sub-title').innerText);
                if (newSub !== null) document.getElementById('sub-title').innerText = newSub;
            };
            const btnSwitch = document.getElementById('btn-switch-theme');
            btnSwitch.onclick = (e) => {
                e.stopPropagation(); STATE.isGestureSwitchEnabled = !STATE.isGestureSwitchEnabled;
                btnSwitch.textContent = STATE.isGestureSwitchEnabled ? "ÊâãÂäøÂàáÊç¢: ÂºÄ" : "ÊâãÂäøÂàáÊç¢: ÂÖ≥";
                if (!STATE.isGestureSwitchEnabled) btnSwitch.classList.add('disabled'); else btnSwitch.classList.remove('disabled');
            };

            // ÊâãÂä®ÈöêËóèÁõëÊéß
            const btnCam = document.getElementById('btn-toggle-cam');
            btnCam.onclick = (e) => {
                e.stopPropagation();
                const wrapper = document.getElementById('webcam-wrapper');
                if (wrapper.style.display === 'none') {
                    wrapper.style.display = 'flex';
                    btnCam.textContent = "ÈöêËóèÁõëÊéß";
                } else {
                    wrapper.style.display = 'none';
                    btnCam.textContent = "ÊòæÁ§∫ÁõëÊéß";
                }
            };

            // üåü Â∏ÆÂä©/ÂàÜ‰∫´ÊåâÈíÆÈÄªËæë
            const btnHelp = document.getElementById('btn-help');
            const helpModal = document.getElementById('help-modal');
            const closeHelp = document.querySelector('.close-help');

            btnHelp.onclick = (e) => { e.stopPropagation(); helpModal.style.display = 'flex'; };
            closeHelp.onclick = (e) => { e.stopPropagation(); helpModal.style.display = 'none'; };

            // Êô∫ËÉΩÂàÜ‰∫´ÊåâÈíÆ
            const btnShareNative = document.getElementById('btn-share-native');
            btnShareNative.onclick = async (e) => {
                e.stopPropagation();
                if (navigator.share) {
                    try {
                        await navigator.share({
                            title: 'My Christmas Gift',
                            text: 'Check out my interactive Christmas Tree!',
                            url: window.location.href
                        });
                    } catch (err) { console.log('Share canceled'); }
                } else {
                    alert("ËØ∑ÂÖàÊåâÁÖß‰∏äÊñπÊïôÁ®ãÁîüÊàêÈìæÊé•ÔºåÁÑ∂ÂêéÂ§çÂà∂ÊµèËßàÂô®Âú∞ÂùÄÊ†èÂàÜ‰∫´ÁªôÂ•ΩÂèãÔºÅ");
                }
            };

            const fsBtn = document.getElementById('btn-fullscreen');
            fsBtn.onclick = (e) => { e.stopPropagation(); document.fullscreenElement ? document.exitFullscreen() : document.documentElement.requestFullscreen(); };
            document.addEventListener('fullscreenchange', () => {
                const isFs = !!document.fullscreenElement; fsBtn.textContent = isFs ? 'ÂèñÊ∂àÂÖ®Â±è' : 'ÂÖ®Â±èÊòæÁ§∫';
                const colMedia = document.getElementById('col-media'), btnImport = document.getElementById('btn-import'), btnExport = document.getElementById('btn-export'), btnSwitch = document.getElementById('btn-switch-theme');
                if (isFs) { colMedia.style.display = 'none'; btnImport.style.display = 'none'; btnExport.style.display = 'none'; btnSwitch.style.display = 'none'; }
                else { colMedia.style.display = 'flex'; btnImport.style.display = 'block'; btnExport.style.display = 'block'; btnSwitch.style.display = 'block'; }
            });
            document.getElementById('btn-export').onclick = (e) => { e.stopPropagation(); exportWholePage(); };
            const importInput = document.getElementById('import-input');
            document.getElementById('btn-import').onclick = (e) => { e.stopPropagation(); importInput.click(); };
            importInput.onchange = (e) => { if (e.target.files[0]) { const reader = new FileReader(); reader.onload = (evt) => importSceneData(evt.target.result); reader.readAsText(e.target.files[0]); } };

            // üåü Ê≥®ÂÜåÊâãÂäøÈù¢ÊùøÊäòÂè†‰∫ã‰ª∂
            const gestureHeader = document.getElementById('gesture-header');
            const gesturePanel = document.getElementById('gesture-panel');
            const gestureToggle = document.getElementById('gesture-toggle');
            if(gestureHeader) {
                gestureHeader.onclick = (e) => {
                    e.stopPropagation();
                    gesturePanel.classList.toggle('collapsed');
                    gestureToggle.innerText = gesturePanel.classList.contains('collapsed') ? '‚ñ≤' : '‚ñº';
                };
            }
        }

        // üåü ÁªàÊûÅ‰∫§‰∫íÊéßÂà∂ÈÄªËæë (Â∑≤‰øÆÂ§çÊâãÂäøÂÜ≤Á™Å)
        function setupInteraction() {
            window.addEventListener('contextmenu', e => e.preventDefault());
            
            // üñ±Ô∏è Èº†Ê†áÂèòÈáè
            let isDragging = false; 
            let startX = 0, startY = 0; 
            let lastX = 0, lastY = 0;

            // üì± Ëß¶Êë∏ÂèòÈáè
            let touchStartX = 0, touchStartY = 0; 
            let initialPinch = null; 
            let longPressTimer = null;      // ÂçïÊåáÈïøÊåâ (‰π¶‰ø°)
            let twoFingerTimer = null;      // üåü ÂèåÊåáÈïøÊåâ (ÊñáÂ≠óÊ®°Âºè)
            let isTwoFingerStatic = false;  // Ê†áËÆ∞ÂèåÊåáÊòØÂê¶‰øùÊåÅÈùôÊ≠¢

            // --- üì± Ëß¶Êë∏‰∫ã‰ª∂ÁõëÂê¨ ---
            document.addEventListener('touchstart', (e) => {
                updateControlPanel('TOUCH'); 
                if (e.target.closest('.control-btn') || e.target.closest('.letter-paper') || e.target.closest('#letter-editor-modal') || e.target.closest('#help-modal')) return;

                // 1. ÂçïÊåáÈÄªËæë
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX; 
                    touchStartY = e.touches[0].clientY; 
                    lastX = touchStartX; 
                    lastY = touchStartY;
                    
                    // ÂçïÊåáÈïøÊåâ -> ‰π¶‰ø°
                    longPressTimer = setTimeout(() => {
                        if (STATE.mode !== 'LETTER') { 
                            enterLetterMode(); 
                            if (navigator.vibrate) navigator.vibrate(50); 
                        }
                    }, 800);
                } 
                // 2. ÂèåÊåáÈÄªËæë (ÂèåÊåáÈïøÊåâ)
                else if (e.touches.length === 2) {
                    // üåüüåüüåü ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÊ£ÄÊµãÂà∞Á¨¨‰∫åÊ†πÊâãÊåáÊó∂ÔºåÁ´ãÂç≥ÂèñÊ∂àÂçïÊåáÈïøÊåâËÆ°Êó∂ üåüüåüüåü
                    clearTimeout(longPressTimer);

                    const dx = e.touches[0].clientX - e.touches[1].clientX; 
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialPinch = Math.sqrt(dx*dx + dy*dy);
                    
                    isTwoFingerStatic = true; 
                    
                    // ÂºÄÂêØÂÄíËÆ°Êó∂Ôºö1ÁßíÂêéËß¶ÂèëÊñáÂ≠óÊ®°Âºè
                    twoFingerTimer = setTimeout(() => {
                        if (isTwoFingerStatic) { 
                            activateTextMode(); 
                            if (navigator.vibrate) navigator.vibrate([50, 100, 50]); 
                            isTwoFingerStatic = false; 
                        }
                    }, 1000); 
                } 
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (e.target.closest('.letter-content')) return; 
                e.preventDefault(); 

                // 1. ÂçïÊåáÊªëÂä®
                if (e.touches.length === 1) {
                    const dx = e.touches[0].clientX - lastX; 
                    const dy = e.touches[0].clientY - lastY;
                    
                    // ÊªëÂä®Êó∂‰πüË¶ÅÂèñÊ∂àÈïøÊåâ
                    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) clearTimeout(longPressTimer);
                    
                    if (STATE.mode === 'TREE') { 
                        STATE.rotation.y += dx * 0.004; 
                        STATE.rotation.x += dy * 0.004; 
                    } else if (STATE.mode === 'SCATTER') { 
                        STATE.spinVel.y += dx * 0.05; 
                    }
                    lastX = e.touches[0].clientX; 
                    lastY = e.touches[0].clientY;
                } 
                // 2. ÂèåÊåáÁßªÂä® (ÊâìÊñ≠ÈïøÊåâÔºåÊâßË°åÊï£ÂºÄ)
                else if (e.touches.length === 2 && initialPinch) {
                    // Êó¢ÁÑ∂Âä®‰∫ÜÔºåËÇØÂÆö‰πü‰∏çÊòØÂçïÊåáÈïøÊåâ‰∫ÜÔºåÂÜçÊ¨°Á°Æ‰øùÊ∏ÖÁêÜ
                    clearTimeout(longPressTimer); 

                    const dx = e.touches[0].clientX - e.touches[1].clientX; 
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const currentDist = Math.sqrt(dx*dx + dy*dy);
                    
                    // ÂÆπÈîôÈòàÂÄº 15px
                    if (Math.abs(currentDist - initialPinch) > 15) {
                        clearTimeout(twoFingerTimer); // ÂèñÊ∂àÂèåÊåáÈïøÊåâ
                        isTwoFingerStatic = false;    
                        
                        if (currentDist > initialPinch * 1.2 && STATE.mode !== 'SCATTER') { 
                            STATE.mode = 'SCATTER'; STATE.scatterScale = 1.0; 
                        } else if (currentDist < initialPinch * 0.8 && STATE.mode === 'SCATTER') { 
                            STATE.mode = 'TREE'; STATE.spinVel.set(0,0); 
                        }
                    }
                } 
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                // ÊâãÊåáÁ¶ªÂºÄÊó∂ÔºåÊ∏ÖÁêÜÊâÄÊúâÂèØËÉΩÁöÑËÆ°Êó∂Âô®
                clearTimeout(longPressTimer);
                clearTimeout(twoFingerTimer);
                
                // ÂçïÊåáÁÇπÂáªÂà§ÂÆö (‰∏îÊ≤°ÊúâËß¶ÂèëËøáÂèåÊåáÈïøÊåâ)
                if (e.changedTouches.length === 1 && !initialPinch && !isTwoFingerStatic) {
                     if (Math.hypot(e.changedTouches[0].clientX - touchStartX, e.changedTouches[0].clientY - touchStartY) < 10) {
                         checkRaycast(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
                     }
                }
                
                if (e.touches.length === 0) {
                    initialPinch = null;
                    isTwoFingerStatic = false;
                }
            });

            // --- üíª Èº†Ê†á‰∫ã‰ª∂ÁõëÂê¨ ---
            document.addEventListener('mousedown', (e) => {
                updateControlPanel('MOUSE'); 
                if (e.target.closest('.control-btn') || e.target.closest('.letter-paper') || e.target.closest('#letter-editor-modal') || e.target.closest('#help-modal')) return;
                isDragging = true; startX = e.clientX; startY = e.clientY; lastX = startX; lastY = startY;

                if (e.button === 1) { enterLetterMode(); return; }
                if (e.buttons === 3) { activateTextMode(); return; }
                if (e.button === 2) {
                    if (STATE.mode !== 'SCATTER') { STATE.mode = 'SCATTER'; STATE.scatterScale = 1.0; }
                    else { STATE.mode = 'TREE'; STATE.spinVel.set(0,0); }
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (Math.abs(e.movementX) > 2 || Math.abs(e.movementY) > 2) updateControlPanel('MOUSE');
                if (!isDragging) return; const dx = e.clientX - lastX; const dy = e.clientY - lastY;
                
                if (e.buttons === 1) {
                    if (STATE.mode === 'TREE') { STATE.rotation.y += dx * 0.005; STATE.rotation.x += dy * 0.005; }
                    else if (STATE.mode === 'SCATTER') { STATE.spinVel.y += dx * 0.05; }
                }
                lastX = e.clientX; lastY = e.clientY;
            });

            document.addEventListener('mouseup', (e) => {
                isDragging = false;
                if (e.button === 0) {
                    const moveDist = Math.hypot(e.clientX - startX, e.clientY - startY);
                    if (moveDist < 5 && STATE.mode !== 'TEXT') { checkRaycast(e.clientX, e.clientY); }
                }
            });

            // ÂèåÂáª -> ÂàáÊç¢‰∏ªÈ¢ò
            document.addEventListener('dblclick', (e) => {
                if (STATE.mode !== 'LETTER' && !e.target.closest('.control-btn')) { switchTheme((STATE.currentThemeIndex + 1) % 3); }
            });

            // ÊªöËΩÆ -> Áº©Êîæ
            document.addEventListener('wheel', (e) => {
                CONFIG.camera.z += e.deltaY * 0.05;
                CONFIG.camera.z = THREE.MathUtils.clamp(CONFIG.camera.z, 20, 100);
                camera.position.z = CONFIG.camera.z;
            });
        }

        function activateTextMode() {
            if (STATE.mode !== 'TEXT') {
                STATE.mode = 'TEXT'; STATE.focusTarget = null;
                STATE.spinVel.x = 0; STATE.spinVel.y = 0; STATE.rotation.x = 0.1; STATE.rotation.y = 0;
            }
            STATE.textModeExpiry = Date.now() + 2000;
        }

        function checkRaycast(x, y) {
            if (STATE.mode === 'LETTER') return;
            mouse.x = (x / window.innerWidth) * 2 - 1; mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(photoMeshGroup.children, true);
            if (intersects.length > 0) {
                let target = intersects[0].object;
                while (target.parent && target.parent !== photoMeshGroup) target = target.parent;
                STATE.mode = 'FOCUS'; STATE.focusTarget = target;
            } else if (STATE.mode === 'FOCUS' || STATE.mode === 'TEXT') {
                STATE.mode = 'TREE'; STATE.focusTarget = null;
            }
        }

        async function initMediaPipe() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });

                video = document.getElementById('webcam');
                const canvasEl = document.getElementById('webcam-preview');
                canvasCtx = canvasEl.getContext('2d');
                drawingUtils = new DrawingUtils(canvasCtx);

                if (navigator.mediaDevices.getUserMedia) {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
                    video.srcObject = stream;
                    video.onloadedmetadata = () => {
                        video.play();
                        canvasEl.width = video.videoWidth; canvasEl.height = video.videoHeight;
                        if (!isMobileDevice()) document.getElementById('webcam-wrapper').style.opacity = 1;
                        predictWebcam();
                    };
                }
            } catch (err) { console.warn("AI Init failed:", err); }
        }

        async function predictWebcam() {
            if (video && video.readyState >= 2 && handLandmarker) {
                if (lastVideoTime !== video.currentTime) {
                    lastVideoTime = video.currentTime;
                    const result = handLandmarker.detectForVideo(video, performance.now());
                    if (canvasCtx && video.videoWidth > 0) {
                        canvasCtx.clearRect(0, 0, canvasCtx.canvas.width, canvasCtx.canvas.height);
                        canvasCtx.drawImage(video, 0, 0, canvasCtx.canvas.width, canvasCtx.canvas.height);
                        if (result.landmarks?.[0]) {
                            drawingUtils.drawConnectors(result.landmarks[0], HandLandmarker.HAND_CONNECTIONS, { color: "#d4af37", lineWidth: 4 });
                            drawingUtils.drawLandmarks(result.landmarks[0], { color: "#ffffff", lineWidth: 1, radius: 2 });
                            processGestures(result.landmarks[0]);
                        } else {
                            STATE.hand.detected = false;
                            // Â¶ÇÊûúÊâãÊ∂àÂ§±‰∫ÜÔºåUI‰∏çÁ´ãÂç≥ÂàáÊç¢ÂõûÈº†Ê†áÔºå‰øùÊåÅÊúÄÂêéÁä∂ÊÄÅÊàñËÆæ‰∏∫ÈªòËÆ§
                        }
                    }
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function processGestures(lm) {
            STATE.hand.detected = true;
            
            // üåü ËæÖÂä©ÔºöÊõ¥Êñ∞UIÁä∂ÊÄÅ
            const updateUI = (gestureName) => updateControlPanel('HAND', gestureName);

            if (STATE.mode === 'LETTER') {
                updateUI("ÈòÖËØª‰∏≠...");
                return;
            }

            const dist = (i, j) => Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);
            const dIndex = dist(8,0), dMiddle = dist(12,0), dRing = dist(16,0), dPinky = dist(20,0);
            const palmSize = dist(0, 9);

            // 1. üëå OKÊâãÂäø -> ÊâìÂºÄ‰π¶‰ø°
            if (dist(4,8) < 0.08 && dMiddle > 0.15 && dMiddle > dIndex * 1.2) {
                updateUI("OK (ÊâìÂºÄ‰π¶‰ø°)");
                if (Date.now() - STATE.letterLastTriggerTime > 1500) { STATE.letterLastTriggerTime = Date.now(); enterLetterMode(); }
                return;
            }

            // 2. ‚úåÔ∏è ÊØîËÄ∂ -> ÊñáÂ≠óÊ®°Âºè
            if (dIndex > palmSize*1.2 && dMiddle > palmSize*1.2 && dRing < dIndex*0.6 && dPinky < dMiddle*0.6) { 
                updateUI("‚úåÔ∏è ÊØîËÄ∂ (ÊñáÂ≠óÊ®°Âºè)");
                activateTextMode(); return; 
            }

            // 3. üëç Á´ñÂ§ßÊãáÊåá -> ÂàáÊç¢‰∏ªÈ¢ò
            if (dist(4,9)>palmSize*0.85 && dist(8,9)<palmSize*0.65 && dist(12,9)<palmSize*0.65 && dist(16,9)<palmSize*0.65 && dist(20,9)<palmSize*0.65) {
                updateUI("üëç ÁÇπËµû (ÂàáÊç¢‰∏ªÈ¢ò)");
                if (STATE.isGestureSwitchEnabled && Date.now() - STATE.gestureDebounceTimer > 2000) { switchTheme((STATE.currentThemeIndex+1)%3); STATE.gestureDebounceTimer = Date.now(); }
            }

            // 4. üëÜ ÊåáÁÇπ -> ËÅöÁÑ¶ÁÖßÁâá
            const isPointing = dIndex > 0.1 && dMiddle < dIndex*0.7 && dRing < dIndex*0.7;
            const avgSpread = (dIndex + dMiddle + dRing + dPinky) / 4;
            const isPalmOpen = avgSpread > CONFIG.gestures.palmOpenThreshold;

            if (isPointing) {
                updateUI("üëÜ ÊåáÁÇπ (ÈÄâ‰∏≠ÁÖßÁâá)");
                STATE.mode = 'FOCUS';
                if (!STATE.wasPointing) {
                    const photos = particleSystem.filter(p => p.type === 'PHOTO');
                    STATE.focusTarget = (photos.length > 0) ? photos[(++STATE.currentPhotoIndex) % photos.length].mesh : STATE.toppers.star;
                }
                STATE.wasPointing = true; STATE.hasPalmCenter = false;
                STATE.spinVel.x *= 0.9; STATE.spinVel.y *= 0.9;
            } else {
                STATE.wasPointing = false;
                // 5. üñê ÊâãÊéåÂº†ÂºÄ -> Êï£ÂºÄ
                if (isPalmOpen) {
                    updateUI("üñêÔ∏è Âº†ÂºÄ (Êï£ÂºÄ/ËÅöÂêà)");
                    if (STATE.mode !== 'SCATTER' && STATE.mode !== 'TEXT') {
                        if (!STATE.hasPalmCenter) { STATE.palmCenter = {x: lm[9].x, y: lm[9].y}; STATE.hasPalmCenter = true; STATE.gestureBaseSpread = avgSpread; STATE.scatterScale = 1.0; }
                        STATE.mode = 'SCATTER';
                    }
                    if (STATE.mode === 'SCATTER') {
                        if (STATE.gestureBaseSpread) STATE.scatterScale += (THREE.MathUtils.clamp(Math.pow(STATE.gestureBaseSpread/avgSpread, 2), 0.1, 5.0) - STATE.scatterScale) * 0.15;
                        
                        const gain = 8.0; 
                        let dx = lm[9].x - STATE.palmCenter.x; let dy = lm[9].y - STATE.palmCenter.y;
                        if (Math.abs(dx) < 0.02) dx = 0; if (Math.abs(dy) < 0.02) dy = 0;
                        STATE.spinVel.x += (THREE.MathUtils.clamp(-dy*gain, -2, 2) - STATE.spinVel.x) * 0.08;
                        STATE.spinVel.y += (THREE.MathUtils.clamp(dx*gain, -2, 2) - STATE.spinVel.y) * 0.08;
                    }
                } else if (STATE.mode !== 'TEXT' && STATE.mode !== 'FOCUS') {
                    updateUI("ÊôÆÈÄöÊâãÂäø (Á©∫Èó≤)");
                    STATE.mode = 'TREE'; STATE.hasPalmCenter = false; STATE.scatterScale = 1.0; STATE.spinVel.x *= 0.9; STATE.spinVel.y *= 0.9;
                }
            }

            if (STATE.mode !== 'FOCUS') {
                STATE.hand.x += ((lm[9].x - 0.5)*3.0 - STATE.hand.x) * 0.1; STATE.hand.y += ((lm[9].y - 0.5)*3.0 - STATE.hand.y) * 0.1;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta(); STATE.time = clock.elapsedTime;
            const inputX = STATE.hand.detected ? STATE.hand.x : 0;

            if (STATE.environmentGroup) {
                const shouldHide = (STATE.mode === 'SCATTER' || STATE.mode === 'FOCUS' || STATE.mode === 'LETTER' || STATE.mode === 'TEXT');
                const targetScale = shouldHide ? 0.01 : 1.0;
                STATE.environmentGroup.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), dt * 3.0);
                STATE.environmentGroup.visible = STATE.environmentGroup.scale.x > 0.02;
            }

            if (STATE.mode === 'LETTER') {
                STATE.rotation.x = THREE.MathUtils.lerp(STATE.rotation.x, Math.PI/4, dt * 1.5); STATE.rotation.y -= 0.1 * dt;
            } else if (STATE.mode === 'TREE') {
                STATE.rotation.y -= 0.4 * dt; STATE.rotation.x = THREE.MathUtils.lerp(STATE.rotation.x, 0.15, dt * 2.0);
                mainGroup.rotation.z = THREE.MathUtils.lerp(mainGroup.rotation.z, inputX * 0.1, dt * 2);
            } else if (STATE.mode === 'SCATTER') {
                STATE.rotation.y += STATE.spinVel.y * dt; STATE.rotation.x += STATE.spinVel.x * dt;
                if (!STATE.hand.detected) { STATE.spinVel.x *= 0.95; STATE.spinVel.y *= 0.95; }
            } else if (STATE.mode === 'TEXT') {
                STATE.rotation.x = 0.1; STATE.rotation.y = 0; STATE.spinVel.x = 0; STATE.spinVel.y = 0;
                if (Date.now() > STATE.textModeExpiry) STATE.mode = 'TREE';
                launchFireworks();
            } else if (STATE.mode === 'FOCUS') {
                _invMatrix.copy(mainGroup.matrixWorld).invert();
            }

            mainGroup.rotation.y = STATE.rotation.y; mainGroup.rotation.x = STATE.rotation.x;

            for (let f of fireworks) f.update(dt);

            if (galaxySystem && galaxySystem.visible) bgGroup.rotation.y -= 0.05 * dt;
            if (snowSystem && snowSystem.visible) {
                const positions = snowSystem.geometry.attributes.position.array; const velocities = snowSystem.geometry.attributes.velocity.array;
                for(let i=0; i<CONFIG.particles.snowCount; i++) {
                    positions[i*3+1] -= CONFIG.particles.snowSpeed * velocities[i] * dt;
                    if (positions[i*3+1] < -50) positions[i*3+1] = 50;
                }
                snowSystem.geometry.attributes.position.needsUpdate = true; bgGroup.rotation.y -= 0.02 * dt;
            }
            if (heartSystem && heartSystem.visible) {
                const positions = heartSystem.geometry.attributes.position.array; const velocities = heartSystem.geometry.attributes.velocity.array; const offsets = heartSystem.geometry.attributes.offset.array;
                for(let i=0; i<CONFIG.particles.heartCount; i++) {
                    positions[i*3+1] += velocities[i] * 5.0 * dt; positions[i*3] += Math.sin(STATE.time + offsets[i]) * 2.0 * dt;
                    if (positions[i*3+1] > 50) positions[i*3+1] = -50;
                }
                heartSystem.geometry.attributes.position.needsUpdate = true; bgGroup.rotation.y -= 0.02 * dt;
            }

            // üåü Ê†∏ÂøÉÈÄªËæëÊõ¥Êñ∞ÔºöÂè™Âú® TREE Ê®°Âºè‰∏ãÊòæÁ§∫ÂÆû‰Ωì‰∏ùÂ∏¶ÔºåÈÅøÂÖç Scatter Êó∂ÁöÑÂ∞¥Â∞¨
            const isTreeMode = (STATE.mode === 'TREE');

            if (STATE.toppers.star && STATE.toppers.star.visible) {
                STATE.toppers.star.rotation.y -= dt; STATE.toppers.star.rotation.z = Math.sin(STATE.time * 2) * 0.1; STATE.toppers.star.scale.setScalar(0.15);
                // ÈáëËâ≤Â§ßËû∫Êóã (ÂÆû‰Ωì) - ‰ªÖÂú®Ê†ëÊ®°Âºè‰∏ãÊòæÁ§∫
                if (STATE.toppers.goldRibbon) {
                    STATE.toppers.goldRibbon.visible = isTreeMode;
                    if (STATE.toppers.goldRibbon.visible) STATE.toppers.goldRibbon.rotation.y -= dt * 0.2; 
                }
            }

            if (STATE.toppers.snow && STATE.toppers.snow.visible) {
                STATE.toppers.snow.rotation.z -= dt * 0.3; STATE.toppers.snow.rotation.y = Math.sin(STATE.time) * 0.2; STATE.toppers.snow.scale.setScalar(0.16);
                // Ê†ëÈ°∂Èõ™Ëä±Â∞èÁéØÁªï (Á≤íÂ≠ê)
                if (STATE.toppers.snowOrbit) {
                    STATE.toppers.snowOrbit.visible = isTreeMode; // ‰πüË∑üÈöèÈöêËóè
                    if (STATE.toppers.snowOrbit.visible) {
                        STATE.toppers.snowOrbit.rotation.y += dt * 1.5; 
                        STATE.toppers.snowOrbit.children.forEach(sprite => { sprite.rotation.z += sprite.userData.rotSpeed * dt; sprite.position.y += Math.sin(STATE.time * 2 + sprite.position.x) * 0.01; });
                    }
                }
                // Ê†ëË∫´ÂÜ∞Èõ™Â§ß‰∏ùÂ∏¶ (ÂÆû‰Ωì)
                if (STATE.toppers.snowRibbon) {
                    STATE.toppers.snowRibbon.visible = isTreeMode;
                    if (STATE.toppers.snowRibbon.visible) STATE.toppers.snowRibbon.rotation.y -= dt * 0.2;
                }
            }

            if (STATE.toppers.heart && STATE.toppers.heart.visible) {
                STATE.toppers.heart.rotation.z = Math.PI + Math.sin(STATE.time) * 0.1; STATE.toppers.heart.scale.setScalar(0.14 * (1.0 + Math.sin(STATE.time * 3) * 0.05));
                // Ê†ëÈ°∂Áà±ÂøÉÂ∞èÁéØÁªï (Á≤íÂ≠ê)
                if (STATE.toppers.heartOrbit) {
                     STATE.toppers.heartOrbit.visible = isTreeMode; // ‰πüË∑üÈöèÈöêËóè
                     if (STATE.toppers.heartOrbit.visible) {
                        STATE.toppers.heartOrbit.rotation.y -= dt * 2.0; 
                        const scale = 1.0 + Math.sin(STATE.time * 3) * 0.1; STATE.toppers.heartOrbit.scale.set(scale, scale, scale);
                     }
                }
                // Ê†ëË∫´Á≤âËâ≤Â§ß‰∏ùÂ∏¶ (ÂÆû‰Ωì)
                if (STATE.toppers.heartRibbon) {
                    STATE.toppers.heartRibbon.visible = isTreeMode;
                    if (STATE.toppers.heartRibbon.visible) STATE.toppers.heartRibbon.rotation.y -= dt * 0.2;
                }
            }

            particleSystem.forEach(p => p.update(dt, STATE.time, STATE.mode, STATE.focusTarget, (STATE.mode === 'FOCUS' ? _invMatrix : null)));
            composer.render();
        }

        init();
    </script>
    <script>
        setTimeout(() => {
            const loader = document.getElementById('loader');
            if(loader && loader.style.display !== 'none') {
                loader.style.opacity = 0; setTimeout(() => loader.style.display = 'none', 1000);
            }
        }, 5000);
    </script>
       <script>
        (function() {
            // ======================================================
            // üîê ÂêçÂ≠óÊòæÁ§∫‰øÆÂ§çÁâà (Â∑≤‰øÆÂ§çÁ©∫Ê†ºÊñπÊ°ÜÈóÆÈ¢ò)
            // ======================================================

            // ‰Ω†ÁöÑÂØÜÁ†Å (‰øùÊåÅ‰∏çÂèò)
            const _key = "ËµµÂÆáÂÆ∏Áà±ÂîêÊµöÁøî";

            // ‰øÆÊ≠£ÂêéÁöÑÂä†ÂØÜÊï∞ÊçÆ
            // Ëøô‰∏≤‰ª£Á†ÅÂØπÂ∫îÔºö"By. ÂÆ∏ Â≠ê" (‰∏≠Èó¥ÊòØÊ†áÂáÜÁ©∫Ê†ºÔºå‰∏çÂÜçÊòØ‰π±Á†Å)
            const _encrypted = "8d375bfe5b9672110ea86d7a2484";

            // ======================================================
            // üö´ Ëß£ÂØÜÈÄªËæë
            // ======================================================
            function _decrypt(_str, _pass) {
                let _res = '';
                try {
                    for (let i = 0; i < _str.length; i += 4) {
                        const _hex = parseInt(_str.substr(i, 4), 16);
                        const _char = _pass.charCodeAt((i / 4) % _pass.length);
                        _res += String.fromCharCode(_hex ^ _char);
                    }
                } catch(e) {}
                return _res;
            }

            try {
                const _target = document.getElementById('copyright-lock');
                if (_target) {
                    _target.innerText = _decrypt(_encrypted, _key);
                    // ÂèåÈáç‰øùÈô©ÔºöÁ°Æ‰øùÂ≠ó‰ΩìËÉΩÊòæÁ§∫‰∏≠Êñá
                    _target.style.fontFamily = "'Microsoft YaHei', sans-serif";
                }
            } catch (e) { console.log('Copyright render error'); }
        })();
    </script>

<script>
(function() {
  var ws = new WebSocket('ws://' + window.location.host + 
             '/jb-server-page?reloadMode=RELOAD_ON_SAVE&'+
             'referrer=' + encodeURIComponent(window.location.pathname));
  ws.onmessage = function (msg) {
      if (msg.data === 'reload') {
          window.location.reload();
      }
      if (msg.data.startsWith('update-css ')) {
          var messageId = msg.data.substring(11);
          var links = document.getElementsByTagName('link');
          for (var i = 0; i < links.length; i++) {
              var link = links[i];
              if (link.rel !== 'stylesheet') continue;
              var clonedLink = link.cloneNode(true);
              var newHref = link.href.replace(/(&|\?)jbUpdateLinksId=\d+/, "$1jbUpdateLinksId=" + messageId);
              if (newHref !== link.href) {
                clonedLink.href = newHref;
              }
              else {
                var indexOfQuest = newHref.indexOf('?');
                if (indexOfQuest >= 0) {
                  // to support ?foo#hash 
                  clonedLink.href = newHref.substring(0, indexOfQuest + 1) + 'jbUpdateLinksId=' + messageId + '&' + 
                                    newHref.substring(indexOfQuest + 1);
                }
                else {
                  clonedLink.href += '?' + 'jbUpdateLinksId=' + messageId;
                }
              }
              link.replaceWith(clonedLink);
          }
      }
  };
})();
</script><script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm/vision_wasm_internal.js" crossorigin="anonymous"></script></body></html>
